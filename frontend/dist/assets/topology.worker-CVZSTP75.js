!function(){"use strict";function t(t){return 1===t||0===t}function o(t){return 2===t||3===t}function n(t){return t.startsWith("0x")||t.startsWith("0X")?t.slice(2,4).toUpperCase():t.slice(0,2).toUpperCase()}function e(t,o){let e=t.forwarded_path??t.original_path;if("string"==typeof e)try{e=JSON.parse(e)}catch{return null}if(!e||!Array.isArray(e)||0===e.length)return null;const s=e.map(t=>String(t).toUpperCase()),i=o?n(o):null,c=s[s.length-1],r=null!==i&&c===i,a=r?s.slice(0,-1):[...s];return{effective:a,original:s,hadLocal:r,effectiveLength:a.length}}function s(t,o){return o-t}function i(t){return t}function c(t,o){const n=t.toUpperCase();return o.startsWith("0x")||o.startsWith("0X")?o.slice(2).toUpperCase().startsWith(n):o.toUpperCase().startsWith(n)}function r(t,o,n,e){const s=(n-t)*Math.PI/180,i=(e-o)*Math.PI/180,c=Math.sin(s/2)*Math.sin(s/2)+Math.cos(t*Math.PI/180)*Math.cos(n*Math.PI/180)*Math.sin(i/2)*Math.sin(i/2);return 2*Math.atan2(Math.sqrt(c),Math.sqrt(1-c))*6371e3}function a(t){return t<500?1:t<2e3?.8:t<5e3?.6:t<1e4?.4:t<2e4?.2:.1}function f(t){if(t.contact_type){const o=t.contact_type.toLowerCase();if("repeater"===o||"rep"===o)return!0;if("companion"===o||"client"===o||"cli"===o)return!1;if("room server"===o||"room_server"===o||"room"===o||"server"===o)return!1}return!0===t.is_repeater||(t.is_repeater,!1)}function l(t,o){if(!t||t<=0)return.1;const n=(Math.floor(Date.now()/1e3)-t)/3600;return n<0?1:Math.exp(-n/12)}function u(t){return!(!t||t<=0)&&(Math.floor(Date.now()/1e3)-t)/3600>336}function h(t,o,n){const e=o.toUpperCase(),s=t.get(e);if(!s||0===s.candidates.length)return{hash:null,confidence:0};if(null==n?void 0:n.isLastHop)return{hash:s.bestMatch,confidence:s.confidence};if(1===(null==n?void 0:n.position))return{hash:s.bestMatch,confidence:s.confidence};if((null==n?void 0:n.position)&&s.bestMatchForPosition.has(n.position)){const t=s.bestMatchForPosition.get(n.position),o=Math.max(t.confidence,s.confidence);return{hash:t.hash,confidence:o}}if((null==n?void 0:n.adjacentPrefixes)&&n.adjacentPrefixes.length>0){let t=s.bestMatch,o=0;for(const e of s.candidates){let s=0;for(const t of n.adjacentPrefixes)s+=e.adjacentPrefixCounts.get(t.toUpperCase())||0;const i=e.combinedScore+s/Math.max(1,e.totalAdjacentObservations)*.3;i>o&&(o=i,t=e.hash)}return{hash:t,confidence:s.confidence}}return{hash:s.bestMatch,confidence:s.confidence}}function d(t,o){return`${o}:${t.join(">")}`}function p(t,o){return`${t}→${o}`}function M(n){const e=n.route??n.route_type;return t(e)?"flood":o(e)?"direct":"unknown"}const y=100;function g(t,o){return[t,o].sort().join("-")}function w(w,m,b,v=.4,S,C,P){const E=[...w].sort((t,o)=>(t.timestamp??0)-(o.timestamp??0)),x=function(t,o,i,c,a){const h=new Map,d=function(t){const o={};for(const[n,e]of Object.entries(t))f(e)&&(o[n]=e);return o}(o),p=new Map,M=void 0!==c&&void 0!==a&&(0!==c||0!==a);if(i){const t=n(i),o={hash:i,prefix:t,positionCounts:new Array(5).fill(0),totalAppearances:0,typicalPosition:0,positionConsistency:0,adjacentPrefixCounts:new Map,totalAdjacentObservations:0,latitude:c,longitude:a,distanceToLocal:0,srcGeoEvidenceScore:0,srcGeoEvidenceCount:0,lastSeenTimestamp:Math.floor(Date.now()/1e3),recencyScore:1,positionScore:0,cooccurrenceScore:0,geographicScore:1,combinedScore:0};p.set(t,[o])}for(const[e,s]of Object.entries(d)){const t=n(e),o=s.last_seen??0;if(u(o))continue;let i;const f=!0===s.zero_hop;M&&s.latitude&&s.longitude&&(0!==s.latitude||0!==s.longitude)&&(i=r(c,a,s.latitude,s.longitude));let h=.2;void 0!==i?h=i<500?1:i<2e3?.8:i<5e3?.6:i<1e4?.4:i<2e4?.2:.1:s.latitude&&s.longitude&&(h=.5),f&&(h=Math.max(h,.95));const d=l(o),y={hash:e,prefix:t,positionCounts:new Array(5).fill(0),totalAppearances:0,typicalPosition:0,positionConsistency:0,adjacentPrefixCounts:new Map,totalAdjacentObservations:0,latitude:s.latitude,longitude:s.longitude,distanceToLocal:i,srcGeoEvidenceScore:0,srcGeoEvidenceCount:0,lastSeenTimestamp:o,recencyScore:d,positionScore:0,cooccurrenceScore:0,geographicScore:h,combinedScore:0},g=p.get(t)||[];g.push(y),p.set(t,g)}for(const n of t){const t=e(n,i);if(!t||0===t.effectiveLength)continue;const c=t.effective,a=n.src_hash,f=a?o[a]:void 0,l=(null==f?void 0:f.latitude)&&(null==f?void 0:f.longitude)&&(0!==f.latitude||0!==f.longitude);for(let o=0;o<c.length;o++){const n=c[o],e=p.get(n);if(!e)continue;const i=s(o,t.effectiveLength),a=Math.min(i-1,4);for(const t of e){if(t.positionCounts[a]++,t.totalAppearances++,1===i&&e.length>1&&l&&t.latitude&&t.longitude){const o=r(f.latitude,f.longitude,t.latitude,t.longitude);let n=0;n=o<500?1:o<2e3?.8:o<5e3?.5:o<1e4?.3:.1,void 0!==t.distanceToLocal&&(t.distanceToLocal<500?n*=1.2:t.distanceToLocal<2e3?n*=1:n*=.8),t.srcGeoEvidenceScore+=n,t.srcGeoEvidenceCount++}if(o>0&&e.length>1&&t.latitude&&t.longitude){const n=c[o-1],e=p.get(n);if(e&&e.length>0){let o,n,s=0;if(1===e.length){const t=e[0];t.latitude&&t.longitude&&(o=t.latitude,n=t.longitude,s=1)}else{const t=[...e].sort((t,o)=>o.combinedScore-t.combinedScore),i=t[0],c=t[1];if(i.latitude&&i.longitude&&i.combinedScore>0){const t=c?(i.combinedScore-c.combinedScore)/i.combinedScore:1;s=Math.min(1,t+.3),s>.4&&(o=i.latitude,n=i.longitude)}}if(void 0!==o&&void 0!==n){const e=r(t.latitude,t.longitude,o,n);let i=0;i=e<500?1:e<2e3?.8:e<5e3?.5:e<1e4?.3:.1,i*=s,t.srcGeoEvidenceScore+=i,t.srcGeoEvidenceCount++}}}if(i>1&&e.length>1&&t.latitude&&t.longitude){const n=o+1;if(n<c.length){const o=c[n],e=p.get(o);if(e&&e.length>0){let o,n,s=0;if(1===e.length){const t=e[0];t.latitude&&t.longitude&&(o=t.latitude,n=t.longitude,s=1)}else{const t=[...e].sort((t,o)=>o.combinedScore-t.combinedScore),i=t[0],c=t[1];if(i.latitude&&i.longitude&&i.combinedScore>0){const t=c?(i.combinedScore-c.combinedScore)/i.combinedScore:1;s=Math.min(1,t+.3),s>.4&&(o=i.latitude,n=i.longitude)}}if(void 0!==o&&void 0!==n){const e=r(t.latitude,t.longitude,o,n);let i=0;i=e<500?1:e<2e3?.8:e<5e3?.5:e<1e4?.3:.1,i*=s,t.srcGeoEvidenceScore+=i,t.srcGeoEvidenceCount++}}}}if(o>0){const n=c[o-1];t.adjacentPrefixCounts.set(n,(t.adjacentPrefixCounts.get(n)||0)+1),t.totalAdjacentObservations++}if(o<c.length-1){const n=c[o+1];t.adjacentPrefixCounts.set(n,(t.adjacentPrefixCounts.get(n)||0)+1),t.totalAdjacentObservations++}}}}let y=1,g=1;for(const n of p.values())for(const t of n)y=Math.max(y,t.totalAppearances),g=Math.max(g,t.totalAdjacentObservations);for(const n of p.values())for(const t of n){if(t.totalAppearances>0){let o=0,n=1;for(let s=0;s<5;s++)t.positionCounts[s]>o&&(o=t.positionCounts[s],n=s+1);t.typicalPosition=n,t.positionConsistency=o/t.totalAppearances;const e=t.totalAppearances/y;t.positionScore=.6*t.positionConsistency+.4*e}if(t.totalAdjacentObservations>0&&(t.cooccurrenceScore=t.totalAdjacentObservations/g),t.combinedScore=.15*t.positionScore+.15*t.cooccurrenceScore+.35*t.geographicScore+.35*t.recencyScore,t.srcGeoEvidenceCount>0){const o=t.srcGeoEvidenceScore/t.srcGeoEvidenceCount*Math.min(t.srcGeoEvidenceCount/50,1)*.3;t.combinedScore+=o}}for(const[n,e]of p){e.sort((t,o)=>o.combinedScore-t.combinedScore);const t=e.length>0?e[0].hash:null;let o=0;if(1===e.length)o=1;else if(e.length>1){const t=e[0].combinedScore,n=e[1].combinedScore;t>0&&(o=Math.min(1,(t-n)/t)),e[0].totalAppearances>2*e[1].totalAppearances&&(o=Math.min(1,o+.2));const s=0,i=e[0].positionCounts[s]||0,c=i+(e[1].positionCounts[s]||0);if(c>=20&&i>=10){const t=i/c;if(t>=.8){const n=.3+1.5*(t-.8);o=Math.min(1,o+n)}}const r=e.reduce((t,o)=>t+o.combinedScore,0);if(r>0){const t=[],n=e.reduce((t,o)=>t+(o.positionCounts[0]||0),0);for(const o of e){const e=n*(o.combinedScore/r);t.push(e)}const s=t[0],i=s+(t[1]||0);if(i>=20&&s>=10){const t=s/i;if(t>=.6){const n=.2+1*(t-.6);o=Math.min(1,o+n)}}}const a=e[0].srcGeoEvidenceScore,f=e[1].srcGeoEvidenceScore;if(e[0].srcGeoEvidenceCount>=10&&a>1.5*f){const t=f>0?a/(a+f):1,n=Math.min(.3,.6*(t-.5));o=Math.min(1,o+n)}}const s=new Map;for(let n=1;n<=5;n++){const t=[...e].sort((t,o)=>{const e=t.positionCounts[n-1]||0;return(o.positionCounts[n-1]||0)-e});if(t.length>0&&t[0].positionCounts[n-1]>0){const o=t[0];let e=1;if(t.length>1){const s=o.positionCounts[n-1],i=s+(t[1].positionCounts[n-1]||0);e=i>0?s/i:0}s.set(n,{hash:o.hash,confidence:e})}}const i={prefix:n,candidates:e,bestMatch:t,confidence:o,isUnambiguous:1===e.length,bestMatchForPosition:s};h.set(n,i)}return h}(E,m,b,S,C),k=function(t,o,n,i,f,l){const u=new Map,d=void 0!==n&&void 0!==i&&(0!==n||0!==i);for(const[e,s]of Object.entries(o)){let t=null,o=.5;d&&s.latitude&&s.longitude&&(0!==s.latitude||0!==s.longitude)&&(t=r(n,i,s.latitude,s.longitude),o=a(t)),s.zero_hop&&(o=Math.max(o,.9)),u.set(e,{hash:e,frequency:0,directForwardCount:0,distanceMeters:t,proximityScore:o,hopPositionCounts:[0,0,0,0,0],avgHopDistance:0,typicalHopPosition:0,hopConsistencyScore:0,frequencyScore:0,combinedScore:0,avgDisambiguationConfidence:0,collisionCount:0,resolutionCount:0})}const p=new Map;for(const r of t){const t=e(r,f);if(t&&t.effectiveLength>=1){const o=t.effective;for(let n=0;n<o.length;n++){const e=o[n],i=s(n,t.effectiveLength);if(l){const t=h(l,e,{position:i,adjacentPrefixes:[...n>0?[o[n-1]]:[],...n<o.length-1?[o[n+1]]:[]],isLastHop:1===i});if(t.hash){const o=u.get(t.hash);if(o){o.frequency++,o.resolutionCount++;const n=p.get(t.hash)||0;p.set(t.hash,n+t.confidence);const s=l.get(e.toUpperCase());s&&!s.isUnambiguous&&o.collisionCount++;const c=Math.min(i-1,4);o.hopPositionCounts[c]++,1===i&&o.directForwardCount++}}}else for(const[t,o]of u)if(c(e,t)){o.frequency++;const t=Math.min(i-1,4);o.hopPositionCounts[t]++,1===i&&o.directForwardCount++}}}if((!t||0===t.effectiveLength)&&r.src_hash){const t=u.get(r.src_hash);if(t){t.frequency++,t.directForwardCount++,t.hopPositionCounts[0]++,t.resolutionCount++;const o=p.get(r.src_hash)||0;p.set(r.src_hash,o+1)}}}let M=0;for(const e of u.values())M=Math.max(M,e.frequency);for(const e of u.values()){let t=0,o=0,n=0,s=1;for(let c=0;c<e.hopPositionCounts.length;c++){const i=e.hopPositionCounts[c],r=c+1;t+=i,o+=i*r,i>n&&(n=i,s=r)}e.avgHopDistance=t>0?o/t:0,e.typicalHopPosition=s,t>0&&n>0&&(e.hopConsistencyScore=n/t),e.frequencyScore=M>0?e.frequency/M:0;const i=p.get(e.hash)||0;e.avgDisambiguationConfidence=e.resolutionCount>0?i/e.resolutionCount:0,e.combinedScore=.3*e.proximityScore+.3*e.hopConsistencyScore+.4*e.frequencyScore}return u}(E,m,S,C,b,x),D=b?n(b):null,A=new Map;for(const[t,o]of k)A.set(t,o.combinedScore);const N=new Map,H=new Map,R=new Map,L=new Map,j=new Map,$=Math.floor(Date.now()/1e3),O=(n,e,s,i,c,r,a)=>{const f=g(n,e),l=N.get(f),[u,h]=n<e?[n,e]:[e,n],d=n===u,p=t(r)||void 0===r,M=o(r),y=(t=>{if(!t||t<=0)return.1;const o=($-t)/3600;return o<0?1:Math.exp(-o/12)})(a);if(l)l.count++,l.confidenceSum+=s,l.recencySum+=y,l.minHopDistance=Math.min(l.minHopDistance,c),c<l.hopDistanceCounts.length&&l.hopDistanceCounts[c]++,i?l.certainCount++:l.uncertainCount++,d?l.forwardCount++:l.reverseCount++,p?l.floodCount++:M&&l.directCount++;else{const t=[0,0,0,0,0,0,0,0,0,0];c<t.length&&t[c]++,N.set(f,{fromHash:u,toHash:h,key:f,count:1,confidenceSum:s,minHopDistance:c,hopDistanceCounts:t,certainCount:i?1:0,uncertainCount:i?0:1,forwardCount:d?1:0,reverseCount:d?0:1,floodCount:p?1:0,directCount:M?1:0,recencySum:y})}};for(const t of E){const o=e(t,b);if(!o)continue;const n=o.effective,c=o.effectiveLength,r=o.original,a=new Set;if(t.src_hash&&r.length>=1){const o=h(x,r[0],{position:c,adjacentPrefixes:r.length>1?[r[1]]:[]}),n=t.src_hash;if(o.hash&&o.hash!==n){const e=Object.keys(m).includes(n),s=o.confidence>=.6&&e,i=o.confidence*(e?1:.8),r=c+1,f=t.route??t.route_type;O(n,o.hash,i,s,r,f,t.timestamp),a.add(n),a.add(o.hash)}}if(b&&c>=1){const o=c-1,e=n[o],s=4===(t.type??t.payload_type);if(s){const o=j.get(e);o?(o.count++,"number"!=typeof t.rssi||isNaN(t.rssi)||(o.rssiSum+=t.rssi,o.rssiCount++),"number"!=typeof t.snr||isNaN(t.snr)||(o.snrSum+=t.snr,o.snrCount++),o.lastSeen=Math.max(o.lastSeen,t.timestamp??0)):j.set(e,{prefix:e,count:1,rssiSum:"number"!=typeof t.rssi||isNaN(t.rssi)?0:t.rssi,rssiCount:"number"!=typeof t.rssi||isNaN(t.rssi)?0:1,snrSum:"number"!=typeof t.snr||isNaN(t.snr)?0:t.snr,snrCount:"number"!=typeof t.snr||isNaN(t.snr)?0:1,lastSeen:t.timestamp??0,resolvedHashes:new Map})}const i=h(x,e,{position:1,adjacentPrefixes:o>0?[n[o-1]]:[],isLastHop:!0});if(s&&i.hash){const t=j.get(e);if(t){const o=t.resolvedHashes.get(i.hash);o?(o.count++,o.confidenceSum+=i.confidence):t.resolvedHashes.set(i.hash,{count:1,confidenceSum:i.confidence})}}if(i.hash&&i.hash!==b){const o=!0,n=i.confidence,e=t.route??t.route_type;O(i.hash,b,n,o,0,e,t.timestamp),a.add(i.hash),a.add(b),L.set(i.hash,(L.get(i.hash)||0)+1)}}for(let e=0;e<c-1;e++){const o=n[e],r=n[e+1],f=s(e,c),l=s(e+1,c),u=1===l,d=h(x,o,{position:f,adjacentPrefixes:[...e>0?[n[e-1]]:[],n[e+1]]}),p=h(x,r,{position:l,adjacentPrefixes:[n[e],...e+2<c?[n[e+2]]:[]],isLastHop:u});if(!d.hash||!p.hash)continue;if(d.hash===p.hash)continue;const M=d.confidence>=.6&&p.confidence>=.6,y=p.confidence>=.9,g=u&&p.confidence>=.6,w=M||y||g;a.add(d.hash),a.add(p.hash),e>0&&e<c-1&&R.set(d.hash,(R.get(d.hash)||0)+1);const m=y?p.confidence:d.confidence*p.confidence;if(!w&&m<v)continue;const b=i(l),S=t.route??t.route_type;O(d.hash,p.hash,m,w,b,S,t.timestamp)}for(const t of a)H.set(t,(H.get(t)||0)+1)}const T=new Map;let F=0;for(const[t,o]of H){const n=R.get(t)||0,e=o>0?n/o:0;T.set(t,e),F=Math.max(F,e)}if(F>0)for(const[t,o]of T)T.set(t,o/F);const K=Math.max(5,Math.floor(.01*w.length)),I=new Set,q=new Map;for(const t of N.values()){const o=t.forwardCount+t.reverseCount>0?Math.min(t.forwardCount,t.reverseCount)/Math.max(t.forwardCount,t.reverseCount):0;for(const n of[t.fromHash,t.toHash]){const t=q.get(n)||{sum:0,count:0};t.sum+=o,t.count++,q.set(n,t)}}const B=[...T.entries()].filter(([t,o])=>(H.get(t)||0)>=K).map(([t,o])=>{const n=q.get(t),e=n&&n.count>0?n.sum/n.count:0;return{hash:t,effectiveScore:o+.2*e,rawScore:o,avgSymmetry:e}}).sort((t,o)=>o.effectiveScore-t.effectiveScore);for(const{hash:t,effectiveScore:o,rawScore:n,avgSymmetry:e}of B)(o>=.5||n>=.35&&e>=.7)&&I.add(t);const G=Math.min(100,Math.floor(.05*w.length)),V=Math.max(...L.values(),1);for(const[t,o]of L){if(t===b)continue;if(I.has(t))continue;const n=q.get(t),e=o/V;if(o>=((n&&n.count>0?n.sum/n.count:0)>=.6?Math.floor(.7*G):G)||e>=.5){I.add(t);const n=o/(H.get(t)||o),e=T.get(t)||0;T.set(t,Math.max(e,n))}}const U=Array.from(I),X=[],z=[],J=[];let W=0,_=0;const Q=new Set(U),Y=new Set;for(const t of N.values()){const o=t.confidenceSum/t.count;W=Math.max(W,t.count),_=Math.max(_,t.certainCount);const n=Q.has(t.fromHash)||Q.has(t.toHash),e=t.certainCount>=5,s=t.forwardCount+t.reverseCount,i=s>0?Math.min(t.forwardCount,t.reverseCount)/Math.max(t.forwardCount,t.reverseCount):0;let c="balanced";i<.7&&s>0&&(c=t.forwardCount>t.reverseCount?"forward":"reverse");const r=t.floodCount+t.directCount>0&&t.directCount>t.floodCount,a=t.count>0?t.recencySum/t.count:0,f={fromHash:t.fromHash,toHash:t.toHash,key:t.key,packetCount:t.count,avgConfidence:o,strength:0,avgRecency:a,hopDistanceFromLocal:t.minHopDistance,isHubConnection:n,isCertain:e,certainCount:t.certainCount,forwardCount:t.forwardCount,reverseCount:t.reverseCount,symmetryRatio:i,dominantDirection:c,floodCount:t.floodCount,directCount:t.directCount,isDirectPathEdge:r};X.push(f),e&&(z.push(f),Y.add(t.key))}for(const t of X)!Y.has(t.key)&&t.packetCount>=2&&J.push(t);for(const t of X){const o=W>0?t.packetCount/W:0;t.strength=.4*o+.4*t.avgConfidence+.2*t.avgRecency}X.sort((t,o)=>o.certainCount-t.certainCount),z.sort((t,o)=>{const n=t.certainCount+(t.isHubConnection?1e3:0);return o.certainCount+(o.isHubConnection?1e3:0)-n}),J.sort((t,o)=>t.packetCount-o.packetCount);const Z=z.slice(0,100),tt=J.slice(0,100),ot=new Map(X.map(t=>[t.key,t])),{loops:nt,loopEdgeKeys:et}=function(t,o,n=1){if(t.length<3)return{loops:[],loopEdgeKeys:new Set};const e=new Map,s=new Map;for(const f of t)s.set(f.key,f),e.has(f.fromHash)||e.set(f.fromHash,new Set),e.has(f.toHash)||e.set(f.toHash,new Set),e.get(f.fromHash).add(f.toHash),e.get(f.toHash).add(f.fromHash);const i=[],c=new Set,r=new Set;function a(t,o,n){if(t===o)return[t];const s=new Set([t]),i=[{node:t,path:[t]}];for(;i.length>0;){const{node:t,path:c}=i.shift(),r=e.get(t);if(r)for(const e of r)if(g(t,e)!==n){if(e===o)return[...c,e];s.has(e)||(s.add(e),i.push({node:e,path:[...c,e]}))}}return null}for(const f of t){const t=a(f.fromHash,f.toHash,f.key);if(t&&t.length>=2){const e=t,a=[f.key];for(let o=0;o<t.length-1;o++){const n=g(t[o],t[o+1]);a.push(n)}const l=[...e].sort().join(",");if(r.has(l))continue;r.add(l);let u=0,h=1/0;for(const t of a){const o=s.get(t);o&&(u+=o.certainCount,h=Math.min(h,o.certainCount),c.add(t))}const d=a.length>0?u/a.length:0,p=!!o&&e.includes(o),M={id:`loop-${i.length}`,edgeKeys:a,nodes:e,size:a.length,avgCertainCount:d,minCertainCount:h===1/0?0:h,includesLocal:p,strength:n>0?h===1/0?0:h/n:0};i.push(M)}}return i.sort((t,o)=>t.includesLocal!==o.includesLocal?t.includesLocal?-1:1:o.strength-t.strength),{loops:i,loopEdgeKeys:c}}(z,b,_);for(const t of X)t.isLoopEdge=et.has(t.key);const st=function(t,o){const n=new Map,e=new Map;let s=0;for(const r of t){if(!r.src_hash)continue;const t=r.original_path??r.forwarded_path;if(!t||!Array.isArray(t)||0===t.length)continue;const e=t.map(t=>"string"==typeof t?t.toUpperCase().slice(0,2):String(t).toUpperCase().slice(0,2)),i=o||"unknown",c=r.src_hash,a=d(e,c);let f=n.get(a);f||(f={id:a,hops:e,srcHash:c,dstHash:i,observationCount:0,firstSeen:r.timestamp,lastSeen:r.timestamp,routeType:M(r),hopCount:e.length},n.set(a,f)),f.observationCount++,f.lastSeen=Math.max(f.lastSeen,r.timestamp),f.firstSeen=Math.min(f.firstSeen,r.timestamp),s++,"direct"===M(r)&&"direct"!==f.routeType&&(f.routeType="direct")}const i=Array.from(n.values());for(const r of i){const t=p(r.srcHash,r.dstHash),o=e.get(t)||[];o.push(r),e.set(t,o)}for(const r of e.values())r.sort((t,o)=>o.observationCount-t.observationCount);const c=new Map;for(const[r,a]of e)a.length>0&&c.set(r,a[0]);return{paths:i,byEndpoints:e,canonicalPaths:c,totalObservations:s,uniquePathCount:i.length}}(E,b),it=function(t,o,n,e){const s=new Map;if(0===t.length||0===n.length)return s;const i=t=>{const o=.2*Math.round(t/.2);return Math.max(0,Math.min(3,o))},c=t=>Math.floor(5*t),r=new Set;for(const y of t)r.add(y.fromHash),r.add(y.toHash);const a=n.map(t=>t.timestamp).filter(t=>void 0!==t&&t>0).sort((t,o)=>t-o),f=a.length>=2?(a[a.length-1]-a[0])/60:1,l=new Map;for(const y of t)l.has(y.fromHash)||l.set(y.fromHash,[]),l.has(y.toHash)||l.set(y.toHash,[]),l.get(y.fromHash).push(y),l.get(y.toHash).push(y);const u=new Set;for(const y of t)y.isLoopEdge&&u.add(y.key);const h=new Set;for(const[,y]of e.canonicalPaths)for(const t of y.hops)h.add(t.toUpperCase());const d=new Map;for(const y of r){const t=l.get(y)||[];if(0===t.length)continue;const o=y.startsWith("0x")?y.slice(2,4).toUpperCase():y.slice(0,2).toUpperCase(),n=new Set;let s=0,i=0,c=0,r=0,a=0,h=0,p=0;for(const e of t){const t=e.fromHash===y?e.toHash:e.fromHash;n.add(t),s+=e.packetCount,i+=e.certainCount,c=Math.max(c,e.certainCount),r+=e.symmetryRatio,a+=e.floodCount,e.isDirectPathEdge&&h++,u.has(e.key)&&p++}const M=n.size,g=t.length>0?r/t.length:0,w=t.length>0?i/t.length:0,m=e.paths.filter(t=>t.hops.some(t=>t.toUpperCase()===o)),b=m.length;let v=0;for(const[,f]of e.canonicalPaths)f.hops.some(t=>t.toUpperCase()===o)&&v++;const S=m.length>0?m.reduce((t,o)=>t+o.hopCount,0)/m.length:0;d.set(y,{neighborCount:M,totalEdgePackets:s,maxEdgeCertainCount:c,avgEdgeCertainCount:w,avgSymmetry:g,forwardingBurden:0,floodForwardRatio:s>0?a/s:0,pathCount:b,canonicalPathCount:v,avgPathLength:S,loopParticipation:t.length>0?p/t.length:0,isInLoop:p>0,edgeDensity:0,trafficRate:f>0?s/f:0,directPathEdgeRatio:t.length>0?h/t.length:0})}const p=[],M=[],g=[],w=[];for(const[,P]of d)P.totalEdgePackets>=y&&(p.push(P.totalEdgePackets),M.push(P.neighborCount),g.push(P.pathCount),w.push(P.trafficRate));p.sort((t,o)=>t-o),M.sort((t,o)=>t-o),g.sort((t,o)=>t-o),w.sort((t,o)=>t-o);const m=(t,o)=>{if(0===t.length)return.5;const n=t.findIndex(t=>t>=o);return-1===n?1:0===n?0:n/t.length},b=M.length>0?Math.max(...M):1;for(const[,y]of d)y.forwardingBurden=m(p,y.totalEdgePackets),y.edgeDensity=b>0?y.neighborCount/b:0;const v=new Map;for(const P of r){const t=d.get(P);if(!t||t.totalEdgePackets<y)continue;const o=P.startsWith("0x")?P.slice(2,4).toUpperCase():P.slice(0,2).toUpperCase(),s=t.forwardingBurden,i=m(M,t.neighborCount),c=.3*t.avgSymmetry,r=Math.min(1,i+c),a=.6*(e.canonicalPaths.size>0?t.canonicalPathCount/e.canonicalPaths.size:0)+.4*m(g,t.pathCount),f=t.loopParticipation,l=.3*s+.3*r+.2*a+.2*f;let u,h=3*l;l<.1&&t.neighborCount<=2?h=0:h<.2&&(h=.2),u=l>=.7&&t.neighborCount>=4?"backbone":t.neighborCount>=4?"hub":l>=.3&&t.neighborCount>=2?"relay":"edge";const p=e.paths.filter(t=>t.hops.some(t=>t.toUpperCase()===o)).flatMap(t=>{const n=t.hops.findIndex(t=>t.toUpperCase()===o);return n>=0?[n+1]:[]}),w=p.length>0?p.reduce((t,o)=>t+o,0)/p.length:0;let b=0;p.length>1&&(b=p.reduce((t,o)=>t+Math.pow(o-w,2),0)/p.length);const S=.3*Math.min(t.avgEdgeCertainCount/10,1)+.3*Math.min(n.length/1e4,1)+.4*t.avgSymmetry;let C;C=n.length<y?"insufficient":n.length<1e4||t.avgSymmetry<.3?"low":n.length<2e4||t.avgSymmetry<.5?"medium":"high",v.set(P,{compositeScore:l,rawFloodDelay:h,networkRole:u,collisionRisk:r,floodParticipationRate:t.floodForwardRatio,avgPathPosition:w,pathPositionVariance:b,pathDiversity:t.pathCount,trafficIntensity:t.trafficRate,confidence:S,observationSymmetry:t.avgSymmetry,dataConfidence:C,factors:{forwarding:s,collision:r,criticality:a,redundancy:f}})}const S=new Map;for(const[y,P]of v){const t=c(i(P.rawFloodDelay));S.has(t)||S.set(t,[]),S.get(t).push(y)}const C=new Map;for(const[,y]of S){if(y.length<=1){if(1===y.length){const t=y[0],o=v.get(t);C.set(t,i(o.rawFloodDelay))}continue}const t=[...y].sort((t,o)=>{const n=v.get(t),e=v.get(o);return n.compositeScore-e.compositeScore});for(let o=0;o<t.length;o++){const n=t[o],e=v.get(n),s=o%3*.2;C.set(n,i(e.rawFloodDelay+s))}}for(const P of r){const t=d.get(P);if(!t||t.totalEdgePackets<y){s.set(P,{floodDelaySec:0,directDelaySec:0,floodSlots:0,directSlots:0,txDelayFactor:0,directTxDelayFactor:0,trafficIntensity:0,directNeighborCount:(null==t?void 0:t.neighborCount)??0,collisionRisk:0,confidence:0,insufficientData:!0,networkRole:"edge",rationale:"Insufficient data (<100 packets observed)",adjustment:"stable",avgPathPosition:0,pathPositionVariance:0,floodParticipationRate:0,pathDiversity:0,positionDelayMs:0,observationSymmetry:(null==t?void 0:t.avgSymmetry)??0,dataConfidence:"insufficient"});continue}const o=v.get(P),n=C.get(P)??i(o.rawFloodDelay),e=i(.28*n),r=c(n),a=c(e);let f,l={backbone:`Backbone: ${t.neighborCount} neighbors, ${Math.round(100*t.avgSymmetry)}% symmetric`,hub:`Hub: ${t.neighborCount} neighbors`,relay:`Relay: ${Math.round(100*t.avgSymmetry)}% symmetric traffic`,edge:"Edge node"}[o.networkRole];o.observationSymmetry>=.6?l+=". High bidirectional visibility (+1 slot)":o.observationSymmetry<.3&&(l+=". ⚠️ Low symmetry (possible observer bias)"),"low"===o.dataConfidence&&(l+=". Limited data"),f=r>c(.7)?"increase":r<c(.7)?"decrease":"stable";const u=0;s.set(P,{floodDelaySec:n,directDelaySec:e,floodSlots:r,directSlots:a,txDelayFactor:n,directTxDelayFactor:e,trafficIntensity:Math.round(10*o.trafficIntensity)/10,directNeighborCount:t.neighborCount,collisionRisk:Math.round(100*o.collisionRisk)/100,confidence:o.confidence,insufficientData:!1,networkRole:o.networkRole,rationale:l,adjustment:f,avgPathPosition:Math.round(10*o.avgPathPosition)/10,pathPositionVariance:Math.round(100*o.pathPositionVariance)/100,floodParticipationRate:Math.round(100*o.floodParticipationRate)/100,pathDiversity:o.pathDiversity,positionDelayMs:u,observationSymmetry:Math.round(100*o.observationSymmetry)/100,dataConfidence:o.dataConfidence})}return s}(X,0,E,st),ct=function(t,o){const e=new Map,s=new Map(o.map(t=>[t.key,t]));for(const n of o)e.set(n.key,0);if(0===t.paths.length)return e;for(const c of t.paths)for(let t=0;t<c.hops.length-1;t++){const s=c.hops[t],i=c.hops[t+1];for(const t of o){const o=n(t.fromHash),r=n(t.toHash);if(o===s&&r===i||o===i&&r===s){const o=e.get(t.key)||0;e.set(t.key,o+c.observationCount);break}}}const i=Math.max(...e.values(),1);for(const[n,c]of e)e.set(n,c/i);for(const[n,c]of e){const t=s.get(n);if(t){const o=.5+.5*t.symmetryRatio;e.set(n,c*o)}}return e}(st,X),rt=function(t,o=3,n=.3){return[...t.entries()].filter(([,t])=>t>=n).sort((t,o)=>o[1]-t[1]).slice(0,o).map(([t])=>t)}(ct,3,.3),{nodeMobility:at,mobileNodes:ft}=function(t,o){const n=new Map,e=[];if(0===t.paths.length)return{nodeMobility:n,mobileNodes:e};const s=36e5,i=t.paths.map(t=>t.lastSeen).sort((t,o)=>t-o),c=i[0],r=i[i.length-1],a=Math.ceil((r-c)/s)||1,f=new Map;for(const l of t.paths){const t=Math.floor((l.lastSeen-c)/s);for(const n of l.hops){let e=n;for(const[t]of Object.entries(o))if((t.startsWith("0x")?t.slice(2,4).toUpperCase():t.slice(0,2).toUpperCase())===n.toUpperCase()){e=t;break}let s=f.get(e);s||(s={paths:new Set,firstSeen:l.firstSeen,lastSeen:l.lastSeen,windowPresence:new Set},f.set(e,s)),s.paths.add(l.id),s.firstSeen=Math.min(s.firstSeen,l.firstSeen),s.lastSeen=Math.max(s.lastSeen,l.lastSeen),s.windowPresence.add(t)}}for(const[l,u]of f){const t=u.paths.size,o=u.lastSeen-u.firstSeen,s=o>0?o/36e5:0,i=a>0?u.windowPresence.size/a:1,c=(1-i)*(1-.5*Math.min(t/10,1)),r=c>.3,f={hash:l,pathVolatility:c,pathDiversity:t,avgPathLifespanHours:s,isMobile:r,lastSeen:u.lastSeen,activeWindowRatio:i};n.set(l,f),r&&e.push(l)}return e.sort((t,o)=>{var e,s;const i=(null==(e=n.get(t))?void 0:e.pathVolatility)??0;return((null==(s=n.get(o))?void 0:s.pathVolatility)??0)-i}),{nodeMobility:n,mobileNodes:e}}(st,m),lt=function(t,o,e,s=20){const i=[];if(0===t.paths.length)return i;const c=new Map;for(const u of o){const t=n(u.fromHash),o=n(u.toHash);c.set(`${t}>${o}`,u),c.set(`${o}>${t}`,u)}const r=new Set;for(const u of e)r.add(n(u));const a=new Map;for(const n of t.paths){if(0===n.hops.length)continue;const t=n.hops[n.hops.length-1],o=a.get(t)||[];o.push(n.id),a.set(t,o)}const f=[...t.paths].sort((t,o)=>o.observationCount-t.observationCount),l=Date.now();for(const n of f.slice(0,s)){if(n.hops.length<2)continue;let t=0,o=1/0,e=null,s=0,f=!1;for(let i=0;i<n.hops.length-1;i++){const a=n.hops[i],l=n.hops[i+1],u=`${a}>${l}`,h=c.get(u);if(h){const n=h.packetCount>0?h.certainCount/h.packetCount:0;t+=n,s++,n<o&&(o=n,e=h.key)}else t+=.1,s++,.1<o&&(o=.1,e=g(a,l));(r.has(a)||r.has(l))&&(f=!0)}const u=s>0?t/s:0,h=o===1/0?0:o,d=(l-n.lastSeen)/36e5,p=Math.exp(-d/24),M=n.observationCount>10&&d<12?.5+.5*(1-d/12):d>48?-.5:0,y=n.hops[n.hops.length-1],w=a.get(y)||[],m=Math.max(0,w.length-1),b="direct"===n.routeType?20:30,v=n.hops.length*b,S=.4*u,C=.3*p,P=(M+1)/2*.15,E=.15*Math.min(m/3,1),x=Math.round(100*(S+C+P+E))/100;i.push({pathKey:n.id,hops:[...n.hops],healthScore:x,weakestLinkKey:e,weakestLinkConfidence:Math.round(100*h)/100,avgEdgeCertainty:Math.round(100*u)/100,observationTrend:Math.round(100*M)/100,alternatePathsCount:m,estimatedLatencyMs:v,observationCount:n.observationCount,routeType:"unknown"===n.routeType?"mixed":n.routeType,lastSeen:n.lastSeen,involvesHub:f})}return i.sort((t,o)=>o.healthScore-t.healthScore),i}(st,X,U,20),ut=[];for(const t of j.values()){let o=null,n=0,e=0;for(const[s,i]of t.resolvedHashes){if(s===b)continue;const t=i.count>0?i.confidenceSum/i.count:0,c=i.count*t;c>n&&(n=c,o=s,e=t)}o&&ut.push({hash:o,prefix:t.prefix,count:t.count,confidence:e,avgRssi:t.rssiCount>0?t.rssiSum/t.rssiCount:null,avgSnr:t.snrCount>0?t.snrSum/t.snrCount:null,lastSeen:t.lastSeen})}ut.sort((t,o)=>o.count-t.count);let ht=0,dt=0;const pt=[],Mt=[];let yt=0;for(const[t,o]of x){ht+=o.confidence;const n=o.candidates.length;o.isUnambiguous||(dt++,Mt.push({prefix:t,candidateCount:n}),o.confidence<.5&&pt.push(t));for(const o of k.values())if(o.hash.toUpperCase().startsWith(t)||o.hash.slice(2).toUpperCase().startsWith(t)){yt+=o.resolutionCount;break}}Mt.sort((t,o)=>o.candidateCount-t.candidateCount);const gt=Mt.slice(0,5);return{edges:X,validatedEdges:Z,weakEdges:tt,certainEdges:Z,uncertainEdges:[],edgeMap:ot,maxPacketCount:W,maxCertainCount:_,neighborAffinity:A,fullAffinity:k,localPrefix:D,centrality:T,hubNodes:U,loops:nt,loopEdgeKeys:et,txDelayRecommendations:it,pathRegistry:st,edgeBetweenness:ct,backboneEdges:rt,nodeMobility:at,mobileNodes:ft,pathHealth:lt,lastHopNeighbors:ut,disambiguationStats:{totalPrefixes:x.size,unambiguousPrefixes:x.size-dt,collisionPrefixes:dt,collisionRate:x.size>0?Math.round(dt/x.size*1e3)/10:0,avgConfidence:x.size>0?Math.round(ht/x.size*1e3)/1e3:0,lowConfidencePrefixes:pt,highCollisionPrefixes:gt,totalResolutions:yt}}}self.onmessage=t=>{const{type:o,payload:n}=t.data;if("compute"!==o)return void self.postMessage({type:"error",error:`Unknown message type: ${o}`});const e=performance.now();try{const{packets:t,neighbors:o,localHash:i,localLat:c,localLon:r,airtimeMs:a}=n,f=w(t,o,i,.5,c,r),l={type:"result",payload:{edges:f.edges,validatedEdges:f.validatedEdges,weakEdges:f.weakEdges,certainEdges:f.certainEdges,uncertainEdges:f.uncertainEdges,maxPacketCount:f.maxPacketCount,maxCertainCount:f.maxCertainCount,localPrefix:f.localPrefix,hubNodes:f.hubNodes,edgeMapEntries:Array.from(f.edgeMap.entries()),neighborAffinityEntries:Array.from(f.neighborAffinity.entries()),fullAffinityEntries:Array.from(f.fullAffinity.entries()),centralityEntries:Array.from(f.centrality.entries()),loops:f.loops,loopEdgeKeyEntries:Array.from(f.loopEdgeKeys),txDelayRecommendationEntries:Array.from(f.txDelayRecommendations.entries()),pathRegistry:(s=f.pathRegistry,{paths:s.paths,byEndpointsEntries:Array.from(s.byEndpoints.entries()),canonicalPathsEntries:Array.from(s.canonicalPaths.entries()),totalObservations:s.totalObservations,uniquePathCount:s.uniquePathCount}),edgeBetweennessEntries:Array.from(f.edgeBetweenness.entries()),backboneEdges:f.backboneEdges,nodeMobilityEntries:Array.from(f.nodeMobility.entries()),mobileNodes:f.mobileNodes,pathHealth:f.pathHealth,lastHopNeighbors:f.lastHopNeighbors,disambiguationStats:f.disambiguationStats},computeTimeMs:performance.now()-e};self.postMessage(l)}catch(i){const t={type:"error",error:i instanceof Error?i.message:"Unknown error in topology worker"};self.postMessage(t)}var s}}();
