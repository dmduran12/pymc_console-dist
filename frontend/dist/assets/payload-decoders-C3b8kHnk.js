var t=Object.defineProperty,e=(e,a,s)=>((e,a,s)=>a in e?t(e,a,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[a]=s)(e,"symbol"!=typeof a?a+"":a,s);import{a2 as a,bn as s,bo as r,bp as n,bq as h,aa as i,br as o,bs as p,bt as l,bu as c,bv as u,bw as d,bx as y,bf as g,by as f,bz as m,bA as b,bB as x,bC as T,bD as C,bE as H,bF as w,bG as S,bH as L,bI as N,bJ as A,bK as $,bL as _,bM as F,bN as U,bO as V,bP as D,bQ as v,bR as k,bS as B,bT as E,bU as P,bV as j,bW as O,bX as I,bY as K,bZ as M,b_ as R,b$ as W,c0 as q,c1 as z,c2 as G,c3 as J,c4 as Q,c5 as X}from"./index-DUGAIAKU.js";class Y{constructor(){e(this,"header",0),e(this,"transportCodes",[0,0]),e(this,"pathLen",0),e(this,"path",new Uint8Array(0)),e(this,"payload",new Uint8Array(0)),e(this,"decrypted",{}),e(this,"_rssi",0),e(this,"_snr",0)}static fromBytes(t){const e=new Y;try{return e.readFrom(t),{success:!0,packet:e}}catch(a){return{success:!1,error:a instanceof Error?a.message:String(a)}}}static fromHex(t){try{const e=a(t);return Y.fromBytes(e)}catch(e){return{success:!1,error:e instanceof Error?e.message:String(e)}}}get routeType(){return this.header&s}get routeTypeName(){return r[this.routeType]??`UNKNOWN(${this.routeType})`}get payloadType(){return this.header>>n&h}get payloadTypeName(){return i[this.payloadType]??`UNKNOWN(${this.payloadType})`}get payloadVersion(){return this.header>>o&p}hasTransportCodes(){return l(this.routeType)}isFlood(){return c(this.routeType)}isDirect(){return u(this.routeType)}get pathBytes(){return Array.from(this.path)}get pathString(){return d(this.path)}get pathHexArray(){return Array.from(this.path).map(t=>y(t,!0))}get payloadLen(){return this.payload.length}get payloadHex(){return g(this.payload,!0)}getPayloadAppData(){const t=L+N+A;return this.payload.length>=t?this.payload.slice(t):new Uint8Array(0)}get rssi(){return this._rssi}set rssi(t){this._rssi=t}get snr(){return this._snr}set snr(t){this._snr=t}readFrom(t){let e=0;const a=t.length;f(e,1,a,"Missing header byte"),this.header=t[e++];const s=this.payloadVersion;if(s>m)throw new Error(`Unsupported packet version: ${s}`);if(this.hasTransportCodes()?(f(e,4,a,"Missing transport codes"),this.transportCodes=[b(t,e),b(t,e+2)],e+=4):this.transportCodes=[0,0],f(e,1,a,"Missing path_len"),this.pathLen=t[e++],this.pathLen>x)throw new Error(`path_len too large: ${this.pathLen} > ${x}`);return f(e,this.pathLen,a,"Truncated path"),this.path=t.slice(e,e+this.pathLen),e+=this.pathLen,this.payload=t.slice(e),T(this.payload.length),!0}writeTo(){let t=1;this.hasTransportCodes()&&(t+=4),t+=1,t+=this.path.length,t+=this.payload.length;const e=new Uint8Array(t);let a=0;return e[a++]=this.header,this.hasTransportCodes()&&(C(this.transportCodes[0],e,a),C(this.transportCodes[1],e,a+2),a+=4),e[a++]=this.path.length,e.set(this.path,a),a+=this.path.length,e.set(this.payload,a),e}toHex(){return g(this.writeTo(),!0)}async calculateHash(){return H(this.payloadType,this.pathLen,this.payload)}async calculateHashString(t){return w(this.payloadType,this.pathLen,this.payload,t)}async calculateCRC(){return S(this.payloadType,this.pathLen,this.payload)}getRawLength(){let t=2+this.pathLen+this.payload.length;return this.hasTransportCodes()&&(t+=4),t}getSummary(){return{header:y(this.header,!0),routeType:this.routeTypeName,payloadType:this.payloadTypeName,version:this.payloadVersion,pathLen:this.pathLen,pathStr:this.pathString,transportCodes:this.hasTransportCodes()?[this.transportCodes[0].toString(16).toUpperCase().padStart(4,"0"),this.transportCodes[1].toString(16).toUpperCase().padStart(4,"0")]:null,payloadLen:this.payload.length,payloadHex:this.payloadHex,rawLength:this.getRawLength()}}toString(){const t=[`[${this.routeTypeName}/${this.payloadTypeName} v${this.payloadVersion}]`,`path=${this.pathString||"(empty)"}`,`payload=${this.payload.length}B`];return this.hasTransportCodes()&&t.push(`transport=[${this.transportCodes[0]},${this.transportCodes[1]}]`),t.join(" ")}}function Z(t){const e=L+N+A+1;if(t.length<e)return null;let a=0;const s=g(t.slice(a,a+L));a+=L;const r=$(t,a);a+=N;const n=g(t.slice(a,a+A));a+=A;const h=t[a++],i=_(h);let o="unknown";switch(h&X){case Q:o="chat";break;case J:o="repeater";break;case G:o="room_server";break;case z:o="sensor"}const p={type:"advert",publicKey:s,timestamp:r,signature:n,flags:h,flagsDescription:i,nodeType:o,rawAppData:g(t.slice(L+N+A))};if(h&F&&a+8<=t.length){const e=t.slice(a,a+8),s=new ArrayBuffer(8);new Uint8Array(s).set(e);const r=new DataView(s),n=r.getInt32(0,!0),h=r.getInt32(4,!0);p.latitude=n/1e6,p.longitude=h/1e6,a+=8}if(h&U&&a<t.length){let e=a;for(;e<t.length&&0!==t[e];)e++;e>a&&(p.name=(new TextDecoder).decode(t.slice(a,e)))}return p}function tt(t,e){const a=function(t){if(t.length<9)return{type:"trace",traceTag:"00000000",traceTagValue:0,authCode:0,flags:0,pathHashes:[],pathString:"",snrValues:[],isComplete:!1,path:[],targetHash:""};const e=$(t,0),a=e.toString(16).toUpperCase().padStart(8,"0"),s=$(t,4),r=t[8],n=t.slice(9),h=Array.from(n).map(t=>y(t,!0)),i=h.join("->");return{type:"trace",traceTag:a,traceTagValue:e,authCode:s,flags:r,pathHashes:h,pathString:i,snrValues:[],isComplete:!1,path:h,targetHash:h.length>0?h[0]:""}}(t);if(!a)return null;const s=[],r=e instanceof Uint8Array?Array.from(e):e;for(let h=0;h<r.length;h++){let t=r[h];t>127&&(t-=256),s.push(t/4)}const n=s.length>=a.pathHashes.length;return{...a,snrValues:s,isComplete:n}}async function et(t){if(t.length<4)return null;const e=t[0],a=y(e,!0),s=t.slice(1,3),r=t.slice(3),n={type:"grp_txt",channelHash:a,text:g(r),decrypted:!1,ciphertextHex:g(r),macHex:g(s)};try{const t=await W(e,s,r);if(t&&t.plaintext.length>=5){n.channelName=t.channelName;const e=t.plaintext,a=$(e,0),s=e[4],r=new TextDecoder("utf-8",{fatal:!1}).decode(e.slice(5)).replace(/\uFFFD/g,"").replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]/g,"").replace(/\x00+$/,"").trim();n.decrypted=!0,n.isPublicHashChannel=!0,n.timestamp=a,n.flags=s,t.macCorrupted&&(n.macCorrupted=!0);const h=r.indexOf(": ");h>0?(n.senderName=r.slice(0,h),n.text=r.slice(h+2)):n.text=r}else{const t=await q(e);n.isPublicHashChannel=t.length>0}}catch{}return n}async function at(t){if(t.length<4)return null;const e=t[0],a=y(e,!0),s=t.slice(1,3),r=t.slice(3),n={type:"grp_data",channelHash:a,dataHex:g(r),dataLength:r.length,decrypted:!1,macHex:g(s)};try{const t=await W(e,s,r);t&&(n.channelName=t.channelName,n.decrypted=!0,n.decryptedHex=g(t.plaintext))}catch{}return n}function st(t,e,a){return{type:"generic",payloadType:e,payloadTypeName:a,rawHex:g(t),length:t.length}}function rt(t){const{payload:e,payloadType:a,payloadTypeName:s}=t;switch(a){case R:return Z(e)??st(e,a,s);case M:return function(t){if(t.length<4)return null;const e=$(t,0);return{type:"ack",crc:e.toString(16).toUpperCase().padStart(8,"0"),crcValue:e}}(e)??st(e,a,s);case K:return function(t){if(0===t.length)return{type:"path",path:[],pathString:""};const e=Array.from(t).map(t=>y(t,!0)),a=e.join("->");return{type:"path",path:e,pathString:a}}(e)??st(e,a,s);case I:return tt(e,t.path)??st(e,a,s);case O:return function(t){if(t.length<2)return null;const e=y(t[0],!0),a=y(t[1],!0),s=t.slice(2);let r="",n=!0;try{const t=new TextDecoder("utf-8",{fatal:!0}).decode(s);/^[\x20-\x7E\u00A0-\uFFFF\n\r\t]*$/.test(t)&&(r=t,n=!1)}catch{}return n&&(r=g(s)),{type:"txt_msg",destHash:e,srcHash:a,timestamp:0,text:r,encrypted:n}}(e)??st(e,a,s);case j:return function(t){if(t.length<4)return null;const e=t[0],a=y(e,!0),s=t.slice(1,3),r=t.slice(3);return{type:"grp_txt",channelHash:a,text:g(r),decrypted:!1,ciphertextHex:g(r),macHex:g(s)}}(e)??st(e,a,s);case P:return function(t){if(t.length<4)return null;const e=t[0],a=y(e,!0),s=t.slice(1,3),r=t.slice(3);return{type:"grp_data",channelHash:a,dataHex:g(r),dataLength:r.length,decrypted:!1,macHex:g(s)}}(e)??st(e,a,s);case E:return function(t){return t.length<4?null:{type:"multipart",messageId:g(t.slice(0,2)),partNumber:t[2],totalParts:t[3],partData:g(t.slice(4))}}(e)??st(e,a,s);default:return st(e,a,s)}}export{Y as P,tt as a,et as b,at as c,rt as d,Z as e};
