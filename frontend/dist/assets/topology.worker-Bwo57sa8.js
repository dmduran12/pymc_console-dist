!function(){"use strict";const e=100;function t(e){return 1===e||0===e}function o(e){return 2===e||3===e}function n(e){return e.startsWith("0x")||e.startsWith("0X")?e.slice(2,4).toUpperCase():e.slice(0,2).toUpperCase()}function s(e,t){let o=e.forwarded_path??e.original_path;if("string"==typeof o)try{o=JSON.parse(o)}catch{return null}if(!o||!Array.isArray(o)||0===o.length)return null;const s=o.map(e=>String(e).toUpperCase()),r=t?n(t):null,i=s[s.length-1],a=null!==r&&i===r,c=a?s.slice(0,-1):[...s];return{effective:c,original:s,hadLocal:a,effectiveLength:c.length}}function r(e,t){return t-e}function i(e){return e}function a(e,t,o,n){const s=(o-e)*Math.PI/180,r=(n-t)*Math.PI/180,i=Math.sin(s/2)*Math.sin(s/2)+Math.cos(e*Math.PI/180)*Math.cos(o*Math.PI/180)*Math.sin(r/2)*Math.sin(r/2);return 2*Math.atan2(Math.sqrt(i),Math.sqrt(1-i))*6371e3}function c(e){return e<500?1:e<2e3?.8:e<5e3?.6:e<1e4?.4:e<2e4?.2:.1}function u(e){if(e.contact_type){const t=e.contact_type.toLowerCase();if("repeater"===t||"rep"===t)return!0;if("companion"===t||"client"===t||"cli"===t)return!1;if("room server"===t||"room_server"===t||"room"===t||"server"===t)return!1}return!0===e.is_repeater||(e.is_repeater,!1)}function l(e,t){if(!e||e<=0)return.1;const o=(Math.floor(Date.now()/1e3)-e)/3600;return o<0?1:Math.exp(-o/12)}function f(e){return!(!e||e<=0)&&(Math.floor(Date.now()/1e3)-e)/3600>336}function h(e,t,o){const n=t.toUpperCase(),s=e.get(n);if(!s||0===s.candidates.length)return{hash:null,confidence:0};if(null==o?void 0:o.isLastHop)return{hash:s.bestMatch,confidence:s.confidence};if(1===(null==o?void 0:o.position))return{hash:s.bestMatch,confidence:s.confidence};if((null==o?void 0:o.position)&&s.bestMatchForPosition.has(o.position)){const e=s.bestMatchForPosition.get(o.position),t=Math.max(e.confidence,s.confidence);return{hash:e.hash,confidence:t}}if((null==o?void 0:o.adjacentPrefixes)&&o.adjacentPrefixes.length>0){let e=s.bestMatch,t=0;for(const n of s.candidates){let s=0;for(const e of o.adjacentPrefixes)s+=n.adjacentPrefixCounts.get(e.toUpperCase())||0;const r=n.combinedScore+s/Math.max(1,n.totalAdjacentObservations)*.3;r>t&&(t=r,e=n.hash)}return{hash:e,confidence:s.confidence}}return{hash:s.bestMatch,confidence:s.confidence}}function d(e,t){return`${t}:${e.join(">")}`}function p(e,t){return`${e}→${t}`}function g(e){const n=e.route??e.route_type;return t(n)?"flood":o(n)?"direct":"unknown"}function m(e,t){return e.toUpperCase()===(t.startsWith("0x")?t.slice(2,4).toUpperCase():t.slice(0,2).toUpperCase())}function y(e,t){return[e,t].sort().join("-")}function C(C,b,v,S=.4,M,w,P){const x=[...C].sort((e,t)=>(e.timestamp??0)-(t.timestamp??0)),E=function(e,t,o,i,c){const h=new Map,d=function(e){const t={};for(const[o,n]of Object.entries(e))u(n)&&(t[o]=n);return t}(t),p=new Map,g=void 0!==i&&void 0!==c&&(0!==i||0!==c);if(o){const e=n(o),t={hash:o,prefix:e,positionCounts:new Array(5).fill(0),totalAppearances:0,typicalPosition:0,positionConsistency:0,adjacentPrefixCounts:new Map,totalAdjacentObservations:0,latitude:i,longitude:c,distanceToLocal:0,srcGeoEvidenceScore:0,srcGeoEvidenceCount:0,lastSeenTimestamp:Math.floor(Date.now()/1e3),recencyScore:1,positionScore:0,cooccurrenceScore:0,geographicScore:1,combinedScore:0};p.set(e,[t])}for(const[s,r]of Object.entries(d)){const e=n(s),t=r.last_seen??0;if(f(t))continue;let o;const u=!0===r.zero_hop;g&&r.latitude&&r.longitude&&(0!==r.latitude||0!==r.longitude)&&(o=a(i,c,r.latitude,r.longitude));let h=.2;void 0!==o?h=o<500?1:o<2e3?.8:o<5e3?.6:o<1e4?.4:o<2e4?.2:.1:r.latitude&&r.longitude&&(h=.5),u&&(h=Math.max(h,.95));const d=l(t),m={hash:s,prefix:e,positionCounts:new Array(5).fill(0),totalAppearances:0,typicalPosition:0,positionConsistency:0,adjacentPrefixCounts:new Map,totalAdjacentObservations:0,latitude:r.latitude,longitude:r.longitude,distanceToLocal:o,srcGeoEvidenceScore:0,srcGeoEvidenceCount:0,lastSeenTimestamp:t,recencyScore:d,positionScore:0,cooccurrenceScore:0,geographicScore:h,combinedScore:0},y=p.get(e)||[];y.push(m),p.set(e,y)}for(const n of e){const e=s(n,o);if(!e||0===e.effectiveLength)continue;const i=e.effective,c=n.src_hash,u=c?t[c]:void 0,l=(null==u?void 0:u.latitude)&&(null==u?void 0:u.longitude)&&(0!==u.latitude||0!==u.longitude);for(let t=0;t<i.length;t++){const o=i[t],n=p.get(o);if(!n)continue;const s=r(t,e.effectiveLength),c=Math.min(s-1,4);for(const e of n){if(e.positionCounts[c]++,e.totalAppearances++,1===s&&n.length>1&&l&&e.latitude&&e.longitude){const t=a(u.latitude,u.longitude,e.latitude,e.longitude);let o=0;o=t<500?1:t<2e3?.8:t<5e3?.5:t<1e4?.3:.1,void 0!==e.distanceToLocal&&(e.distanceToLocal<500?o*=1.2:e.distanceToLocal<2e3?o*=1:o*=.8),e.srcGeoEvidenceScore+=o,e.srcGeoEvidenceCount++}if(t>0&&n.length>1&&e.latitude&&e.longitude){const o=i[t-1],n=p.get(o);if(n&&n.length>0){let t,o,s=0;if(1===n.length){const e=n[0];e.latitude&&e.longitude&&(t=e.latitude,o=e.longitude,s=1)}else{const e=[...n].sort((e,t)=>t.combinedScore-e.combinedScore),r=e[0],i=e[1];if(r.latitude&&r.longitude&&r.combinedScore>0){const e=i?(r.combinedScore-i.combinedScore)/r.combinedScore:1;s=Math.min(1,e+.3),s>.4&&(t=r.latitude,o=r.longitude)}}if(void 0!==t&&void 0!==o){const n=a(e.latitude,e.longitude,t,o);let r=0;r=n<500?1:n<2e3?.8:n<5e3?.5:n<1e4?.3:.1,r*=s,e.srcGeoEvidenceScore+=r,e.srcGeoEvidenceCount++}}}if(s>1&&n.length>1&&e.latitude&&e.longitude){const o=t+1;if(o<i.length){const t=i[o],n=p.get(t);if(n&&n.length>0){let t,o,s=0;if(1===n.length){const e=n[0];e.latitude&&e.longitude&&(t=e.latitude,o=e.longitude,s=1)}else{const e=[...n].sort((e,t)=>t.combinedScore-e.combinedScore),r=e[0],i=e[1];if(r.latitude&&r.longitude&&r.combinedScore>0){const e=i?(r.combinedScore-i.combinedScore)/r.combinedScore:1;s=Math.min(1,e+.3),s>.4&&(t=r.latitude,o=r.longitude)}}if(void 0!==t&&void 0!==o){const n=a(e.latitude,e.longitude,t,o);let r=0;r=n<500?1:n<2e3?.8:n<5e3?.5:n<1e4?.3:.1,r*=s,e.srcGeoEvidenceScore+=r,e.srcGeoEvidenceCount++}}}}if(t>0){const o=i[t-1];e.adjacentPrefixCounts.set(o,(e.adjacentPrefixCounts.get(o)||0)+1),e.totalAdjacentObservations++}if(t<i.length-1){const o=i[t+1];e.adjacentPrefixCounts.set(o,(e.adjacentPrefixCounts.get(o)||0)+1),e.totalAdjacentObservations++}}}}let m=1,y=1;for(const n of p.values())for(const e of n)m=Math.max(m,e.totalAppearances),y=Math.max(y,e.totalAdjacentObservations);for(const n of p.values())for(const e of n){if(e.totalAppearances>0){let t=0,o=1;for(let s=0;s<5;s++)e.positionCounts[s]>t&&(t=e.positionCounts[s],o=s+1);e.typicalPosition=o,e.positionConsistency=t/e.totalAppearances;const n=e.totalAppearances/m;e.positionScore=.6*e.positionConsistency+.4*n}if(e.totalAdjacentObservations>0&&(e.cooccurrenceScore=e.totalAdjacentObservations/y),e.combinedScore=.15*e.positionScore+.15*e.cooccurrenceScore+.35*e.geographicScore+.35*e.recencyScore,e.srcGeoEvidenceCount>0){const t=e.srcGeoEvidenceScore/e.srcGeoEvidenceCount*Math.min(e.srcGeoEvidenceCount/50,1)*.3;e.combinedScore+=t}}for(const[n,s]of p){s.sort((e,t)=>t.combinedScore-e.combinedScore);const e=s.length>0?s[0].hash:null;let t=0;if(1===s.length)t=1;else if(s.length>1){const e=s[0].combinedScore,o=s[1].combinedScore;e>0&&(t=Math.min(1,(e-o)/e)),s[0].totalAppearances>2*s[1].totalAppearances&&(t=Math.min(1,t+.2));const n=0,r=s[0].positionCounts[n]||0,i=r+(s[1].positionCounts[n]||0);if(i>=20&&r>=10){const e=r/i;if(e>=.8){const o=.3+1.5*(e-.8);t=Math.min(1,t+o)}}const a=s.reduce((e,t)=>e+t.combinedScore,0);if(a>0){const e=[],o=s.reduce((e,t)=>e+(t.positionCounts[0]||0),0);for(const t of s){const n=o*(t.combinedScore/a);e.push(n)}const n=e[0],r=n+(e[1]||0);if(r>=20&&n>=10){const e=n/r;if(e>=.6){const o=.2+1*(e-.6);t=Math.min(1,t+o)}}}const c=s[0].srcGeoEvidenceScore,u=s[1].srcGeoEvidenceScore;if(s[0].srcGeoEvidenceCount>=10&&c>1.5*u){const e=u>0?c/(c+u):1,o=Math.min(.3,.6*(e-.5));t=Math.min(1,t+o)}}const o=new Map;for(let n=1;n<=5;n++){const e=[...s].sort((e,t)=>{const o=e.positionCounts[n-1]||0;return(t.positionCounts[n-1]||0)-o});if(e.length>0&&e[0].positionCounts[n-1]>0){const t=e[0];let s=1;if(e.length>1){const o=t.positionCounts[n-1],r=o+(e[1].positionCounts[n-1]||0);s=r>0?o/r:0}o.set(n,{hash:t.hash,confidence:s})}}const r={prefix:n,candidates:s,bestMatch:e,confidence:t,isUnambiguous:1===s.length,bestMatchForPosition:o};h.set(n,r)}return h}(x,b,v,M,w),k=function(e,t,o,n,i,u){const l=new Map,f=void 0!==o&&void 0!==n&&(0!==o||0!==n);for(const[s,r]of Object.entries(t)){let e=null,t=.5;f&&r.latitude&&r.longitude&&(0!==r.latitude||0!==r.longitude)&&(e=a(o,n,r.latitude,r.longitude),t=c(e)),r.zero_hop&&(t=Math.max(t,.9)),l.set(s,{hash:s,frequency:0,directForwardCount:0,distanceMeters:e,proximityScore:t,hopPositionCounts:[0,0,0,0,0],avgHopDistance:0,typicalHopPosition:0,hopConsistencyScore:0,frequencyScore:0,combinedScore:0,avgDisambiguationConfidence:0,collisionCount:0,resolutionCount:0})}const d=new Map;for(const a of e){const e=s(a,i);if(e&&e.effectiveLength>=1){const t=e.effective;for(let o=0;o<t.length;o++){const n=t[o],s=r(o,e.effectiveLength);if(u){const e=h(u,n,{position:s,adjacentPrefixes:[...o>0?[t[o-1]]:[],...o<t.length-1?[t[o+1]]:[]],isLastHop:1===s});if(e.hash){const t=l.get(e.hash);if(t){t.frequency++,t.resolutionCount++;const o=d.get(e.hash)||0;d.set(e.hash,o+e.confidence);const r=u.get(n.toUpperCase());r&&!r.isUnambiguous&&t.collisionCount++;const i=Math.min(s-1,4);t.hopPositionCounts[i]++,1===s&&t.directForwardCount++}}}else for(const[e,t]of l)if(m(n,e)){t.frequency++;const e=Math.min(s-1,4);t.hopPositionCounts[e]++,1===s&&t.directForwardCount++}}}if((!e||0===e.effectiveLength)&&a.src_hash){const e=l.get(a.src_hash);if(e){e.frequency++,e.directForwardCount++,e.hopPositionCounts[0]++,e.resolutionCount++;const t=d.get(a.src_hash)||0;d.set(a.src_hash,t+1)}}}let p=0;for(const s of l.values())p=Math.max(p,s.frequency);for(const s of l.values()){let e=0,t=0,o=0,n=1;for(let i=0;i<s.hopPositionCounts.length;i++){const r=s.hopPositionCounts[i],a=i+1;e+=r,t+=r*a,r>o&&(o=r,n=a)}s.avgHopDistance=e>0?t/e:0,s.typicalHopPosition=n,e>0&&o>0&&(s.hopConsistencyScore=o/e),s.frequencyScore=p>0?s.frequency/p:0;const r=d.get(s.hash)||0;s.avgDisambiguationConfidence=s.resolutionCount>0?r/s.resolutionCount:0,s.combinedScore=.3*s.proximityScore+.3*s.hopConsistencyScore+.4*s.frequencyScore}return l}(x,b,M,w,v,E),_=v?n(v):null,H=new Map;for(const[e,t]of k)H.set(e,t.combinedScore);const R=new Map,D=new Map,j=new Map,A=new Map,L=new Map,$=Math.floor(Date.now()/1e3),U=(e,n,s,r,i,a,c)=>{const u=y(e,n),l=R.get(u),[f,h]=e<n?[e,n]:[n,e],d=e===f,p=t(a)||void 0===a,g=o(a),m=(e=>{if(!e||e<=0)return.1;const t=($-e)/3600;return t<0?1:Math.exp(-t/12)})(c);if(l)l.count++,l.confidenceSum+=s,l.recencySum+=m,l.minHopDistance=Math.min(l.minHopDistance,i),i<l.hopDistanceCounts.length&&l.hopDistanceCounts[i]++,r?l.certainCount++:l.uncertainCount++,d?l.forwardCount++:l.reverseCount++,p?l.floodCount++:g&&l.directCount++;else{const e=[0,0,0,0,0,0,0,0,0,0];i<e.length&&e[i]++,R.set(u,{fromHash:f,toHash:h,key:u,count:1,confidenceSum:s,minHopDistance:i,hopDistanceCounts:e,certainCount:r?1:0,uncertainCount:r?0:1,forwardCount:d?1:0,reverseCount:d?0:1,floodCount:p?1:0,directCount:g?1:0,recencySum:m})}};for(const e of x){const t=s(e,v);if(!t)continue;const o=t.effective,n=t.effectiveLength,a=t.original,c=new Set;if(e.src_hash&&a.length>=1){const t=h(E,a[0],{position:n,adjacentPrefixes:a.length>1?[a[1]]:[]}),o=e.src_hash;if(t.hash&&t.hash!==o){const s=Object.keys(b).includes(o),r=t.confidence>=.6&&s,i=t.confidence*(s?1:.8),a=n+1,u=e.route??e.route_type;U(o,t.hash,i,r,a,u,e.timestamp),c.add(o),c.add(t.hash)}}if(v&&n>=1){const t=n-1,s=o[t],r=4===(e.type??e.payload_type);if(r){const t=L.get(s);t?(t.count++,"number"!=typeof e.rssi||isNaN(e.rssi)||(t.rssiSum+=e.rssi,t.rssiCount++),"number"!=typeof e.snr||isNaN(e.snr)||(t.snrSum+=e.snr,t.snrCount++),t.lastSeen=Math.max(t.lastSeen,e.timestamp??0)):L.set(s,{prefix:s,count:1,rssiSum:"number"!=typeof e.rssi||isNaN(e.rssi)?0:e.rssi,rssiCount:"number"!=typeof e.rssi||isNaN(e.rssi)?0:1,snrSum:"number"!=typeof e.snr||isNaN(e.snr)?0:e.snr,snrCount:"number"!=typeof e.snr||isNaN(e.snr)?0:1,lastSeen:e.timestamp??0,resolvedHashes:new Map})}const i=h(E,s,{position:1,adjacentPrefixes:t>0?[o[t-1]]:[],isLastHop:!0});if(r&&i.hash){const e=L.get(s);if(e){const t=e.resolvedHashes.get(i.hash);t?(t.count++,t.confidenceSum+=i.confidence):e.resolvedHashes.set(i.hash,{count:1,confidenceSum:i.confidence})}}if(i.hash&&i.hash!==v){const t=!0,o=i.confidence,n=e.route??e.route_type;U(i.hash,v,o,t,0,n,e.timestamp),c.add(i.hash),c.add(v),A.set(i.hash,(A.get(i.hash)||0)+1)}}for(let s=0;s<n-1;s++){const t=o[s],a=o[s+1],u=r(s,n),l=r(s+1,n),f=1===l,d=h(E,t,{position:u,adjacentPrefixes:[...s>0?[o[s-1]]:[],o[s+1]]}),p=h(E,a,{position:l,adjacentPrefixes:[o[s],...s+2<n?[o[s+2]]:[]],isLastHop:f});if(!d.hash||!p.hash)continue;if(d.hash===p.hash)continue;const g=d.confidence>=.6&&p.confidence>=.6,m=p.confidence>=.9,y=f&&p.confidence>=.6,C=g||m||y;c.add(d.hash),c.add(p.hash),s>0&&s<n-1&&j.set(d.hash,(j.get(d.hash)||0)+1);const b=m?p.confidence:d.confidence*p.confidence;if(!C&&b<S)continue;const v=i(l),M=e.route??e.route_type;U(d.hash,p.hash,b,C,v,M,e.timestamp)}for(const e of c)D.set(e,(D.get(e)||0)+1)}const N=new Map;let O=0;for(const[e,t]of D){const o=j.get(e)||0,n=t>0?o/t:0;N.set(e,n),O=Math.max(O,n)}if(O>0)for(const[e,t]of N)N.set(e,t/O);const F=new Set,T=new Set,I=[...A.values()].reduce((e,t)=>e+t,0);for(const[e,t]of A){if(e===v)continue;const o=I>0?t/I:0;if(o>=.1){F.add(e);const t=N.get(e)||0;N.set(e,Math.max(t,o))}else if(o>=.07){T.add(e);const t=N.get(e)||0;N.set(e,Math.max(t,o))}}const q=Array.from(F),G=Array.from(T),z=[],V=[],W=[];let B=0,K=0;const J=new Set(q),X=new Set;for(const e of R.values()){const t=e.confidenceSum/e.count;B=Math.max(B,e.count),K=Math.max(K,e.certainCount);const o=J.has(e.fromHash)||J.has(e.toHash),n=e.certainCount>=5,s=e.forwardCount+e.reverseCount,r=s>0?Math.min(e.forwardCount,e.reverseCount)/Math.max(e.forwardCount,e.reverseCount):0;let i="balanced";r<.7&&s>0&&(i=e.forwardCount>e.reverseCount?"forward":"reverse");const a=e.floodCount+e.directCount>0&&e.directCount>e.floodCount,c=e.count>0?e.recencySum/e.count:0,u={fromHash:e.fromHash,toHash:e.toHash,key:e.key,packetCount:e.count,avgConfidence:t,strength:0,avgRecency:c,hopDistanceFromLocal:e.minHopDistance,isHubConnection:o,isCertain:n,certainCount:e.certainCount,forwardCount:e.forwardCount,reverseCount:e.reverseCount,symmetryRatio:r,dominantDirection:i,floodCount:e.floodCount,directCount:e.directCount,isDirectPathEdge:a};z.push(u),n&&(V.push(u),X.add(e.key))}for(const e of z)!X.has(e.key)&&e.packetCount>=2&&W.push(e);for(const e of z){const t=B>0?e.packetCount/B:0;e.strength=.4*t+.4*e.avgConfidence+.2*e.avgRecency}z.sort((e,t)=>t.certainCount-e.certainCount),V.sort((e,t)=>{const o=e.certainCount+(e.isHubConnection?1e3:0);return t.certainCount+(t.isHubConnection?1e3:0)-o}),W.sort((e,t)=>e.packetCount-t.packetCount);const Y=V.slice(0,100),Q=W.slice(0,100),Z=new Map(z.map(e=>[e.key,e])),{loops:ee,loopEdgeKeys:te}=function(e,t,o=1){if(e.length<3)return{loops:[],loopEdgeKeys:new Set};const n=new Map,s=new Map;for(const u of e)s.set(u.key,u),n.has(u.fromHash)||n.set(u.fromHash,new Set),n.has(u.toHash)||n.set(u.toHash,new Set),n.get(u.fromHash).add(u.toHash),n.get(u.toHash).add(u.fromHash);const r=[],i=new Set,a=new Set;function c(e,t,o){if(e===t)return[e];const s=new Set([e]),r=[{node:e,path:[e]}];for(;r.length>0;){const{node:e,path:i}=r.shift(),a=n.get(e);if(a)for(const n of a)if(y(e,n)!==o){if(n===t)return[...i,n];s.has(n)||(s.add(n),r.push({node:n,path:[...i,n]}))}}return null}for(const u of e){const e=c(u.fromHash,u.toHash,u.key);if(e&&e.length>=2){const n=e,c=[u.key];for(let t=0;t<e.length-1;t++){const o=y(e[t],e[t+1]);c.push(o)}const l=[...n].sort().join(",");if(a.has(l))continue;a.add(l);let f=0,h=1/0;for(const e of c){const t=s.get(e);t&&(f+=t.certainCount,h=Math.min(h,t.certainCount),i.add(e))}const d=c.length>0?f/c.length:0,p=!!t&&n.includes(t),g={id:`loop-${r.length}`,edgeKeys:c,nodes:n,size:c.length,avgCertainCount:d,minCertainCount:h===1/0?0:h,includesLocal:p,strength:o>0?h===1/0?0:h/o:0};r.push(g)}}return r.sort((e,t)=>e.includesLocal!==t.includesLocal?e.includesLocal?-1:1:t.strength-e.strength),{loops:r,loopEdgeKeys:i}}(V,v,K);for(const e of z)e.isLoopEdge=te.has(e.key);const oe=function(e,t){const o=new Map,n=new Map;let s=0;for(const a of e){if(!a.src_hash)continue;const e=a.original_path??a.forwarded_path;if(!e||!Array.isArray(e)||0===e.length)continue;const n=e.map(e=>"string"==typeof e?e.toUpperCase().slice(0,2):String(e).toUpperCase().slice(0,2)),r=t||"unknown",i=a.src_hash,c=d(n,i);let u=o.get(c);u||(u={id:c,hops:n,srcHash:i,dstHash:r,observationCount:0,firstSeen:a.timestamp,lastSeen:a.timestamp,routeType:g(a),hopCount:n.length},o.set(c,u)),u.observationCount++,u.lastSeen=Math.max(u.lastSeen,a.timestamp),u.firstSeen=Math.min(u.firstSeen,a.timestamp),s++,"direct"===g(a)&&"direct"!==u.routeType&&(u.routeType="direct")}const r=Array.from(o.values());for(const a of r){const e=p(a.srcHash,a.dstHash),t=n.get(e)||[];t.push(a),n.set(e,t)}for(const a of n.values())a.sort((e,t)=>t.observationCount-e.observationCount);const i=new Map;for(const[a,c]of n)c.length>0&&i.set(a,c[0]);return{paths:r,byEndpoints:n,canonicalPaths:i,totalObservations:s,uniquePathCount:r.length}}(x,v),ne=function(t,o,n,s){const r=new Map;if(0===t.length||0===n.length)return r;const i=e=>{const t=.2*Math.round(e/.2);return Math.max(0,Math.min(5,t))},a=e=>Math.floor(5*e),c=new Set;for(const e of t)c.add(e.fromHash),c.add(e.toHash);const u=n.map(e=>e.timestamp).filter(e=>void 0!==e&&e>0).sort((e,t)=>e-t),l=u.length>=2?(u[u.length-1]-u[0])/60:1,f=new Map;for(const e of t)f.has(e.fromHash)||f.set(e.fromHash,[]),f.has(e.toHash)||f.set(e.toHash,[]),f.get(e.fromHash).push(e),f.get(e.toHash).push(e);const h=new Set;for(const e of t)e.isLoopEdge&&h.add(e.key);const d=new Set;for(const[,e]of s.canonicalPaths)for(const t of e.hops)d.add(t.toUpperCase());const p=new Map;for(const e of c){const t=f.get(e)||[];if(0===t.length)continue;const o=e.startsWith("0x")?e.slice(2,4).toUpperCase():e.slice(0,2).toUpperCase(),n=new Set;let r=0,i=0,a=0,c=0,u=0,d=0,g=0;for(const s of t){const t=s.fromHash===e?s.toHash:s.fromHash;n.add(t),r+=s.packetCount,i+=s.certainCount,a=Math.max(a,s.certainCount),c+=s.symmetryRatio,u+=s.floodCount,s.isDirectPathEdge&&d++,h.has(s.key)&&g++}const m=n.size,y=t.length>0?c/t.length:0,C=t.length>0?i/t.length:0,b=s.paths.filter(e=>e.hops.some(e=>e.toUpperCase()===o)),v=b.length;let S=0;for(const[,e]of s.canonicalPaths)e.hops.some(e=>e.toUpperCase()===o)&&S++;const M=b.length>0?b.reduce((e,t)=>e+t.hopCount,0)/b.length:0;p.set(e,{neighborCount:m,totalEdgePackets:r,maxEdgeCertainCount:a,avgEdgeCertainCount:C,avgSymmetry:y,forwardingBurden:0,floodForwardRatio:r>0?u/r:0,pathCount:v,canonicalPathCount:S,avgPathLength:M,loopParticipation:t.length>0?g/t.length:0,isInLoop:g>0,edgeDensity:0,trafficRate:l>0?r/l:0,directPathEdgeRatio:t.length>0?d/t.length:0})}const g=[],m=[],y=[],C=[];for(const[,P]of p)P.totalEdgePackets>=e&&(g.push(P.totalEdgePackets),m.push(P.neighborCount),y.push(P.pathCount),C.push(P.trafficRate));g.sort((e,t)=>e-t),m.sort((e,t)=>e-t),y.sort((e,t)=>e-t),C.sort((e,t)=>e-t);const b=(e,t)=>{if(0===e.length)return.5;const o=e.findIndex(e=>e>=t);return-1===o?1:0===o?0:o/e.length},v=m.length>0?Math.max(...m):1;for(const[,e]of p)e.forwardingBurden=b(g,e.totalEdgePackets),e.edgeDensity=v>0?e.neighborCount/v:0;const S=new Map;for(const P of c){const t=p.get(P);if(!t||t.totalEdgePackets<e)continue;const o=P.startsWith("0x")?P.slice(2,4).toUpperCase():P.slice(0,2).toUpperCase(),r=t.forwardingBurden,i=b(m,t.neighborCount),a=.3*t.avgSymmetry,c=Math.min(1,i+a),u=.6*(s.canonicalPaths.size>0?t.canonicalPathCount/s.canonicalPaths.size:0)+.4*b(y,t.pathCount),l=t.loopParticipation,f=.3*r+.3*c+.2*u+.2*l;let h,d=.4+3.6*f;(f<.1&&t.neighborCount<=2||d<.4)&&(d=.4),h=f>=.7&&t.neighborCount>=4?"backbone":t.neighborCount>=4?"hub":f>=.3&&t.neighborCount>=2?"relay":"edge";const g=s.paths.filter(e=>e.hops.some(e=>e.toUpperCase()===o)).flatMap(e=>{const t=e.hops.findIndex(e=>e.toUpperCase()===o);return t>=0?[t+1]:[]}),C=g.length>0?g.reduce((e,t)=>e+t,0)/g.length:0;let v=0;g.length>1&&(v=g.reduce((e,t)=>e+Math.pow(t-C,2),0)/g.length);const M=.3*Math.min(t.avgEdgeCertainCount/10,1)+.3*Math.min(n.length/1e3,1)+.4*t.avgSymmetry;let w;w=n.length<e?"insufficient":n.length<500?"low":n.length<1e3?"medium":"high",S.set(P,{compositeScore:f,rawFloodDelay:d,networkRole:h,collisionRisk:c,floodParticipationRate:t.floodForwardRatio,avgPathPosition:C,pathPositionVariance:v,pathDiversity:t.pathCount,trafficIntensity:t.trafficRate,confidence:M,observationSymmetry:t.avgSymmetry,dataConfidence:w,factors:{forwarding:r,collision:c,criticality:u,redundancy:l}})}const M=new Map;for(const[e,P]of S){const t=a(i(P.rawFloodDelay));M.has(t)||M.set(t,[]),M.get(t).push(e)}const w=new Map;for(const[,e]of M){if(e.length<=1){if(1===e.length){const t=e[0],o=S.get(t);w.set(t,i(o.rawFloodDelay))}continue}const t=[...e].sort((e,t)=>{const o=S.get(e),n=S.get(t);return o.compositeScore-n.compositeScore});for(let e=0;e<t.length;e++){const o=t[e],n=S.get(o),s=e%3*.2;w.set(o,i(n.rawFloodDelay+s))}}for(const P of c){const t=p.get(P);if(!t||t.totalEdgePackets<e){r.set(P,{floodFactor:0,directFactor:0,floodSlots:0,directSlots:0,floodDelaySec:0,directDelaySec:0,txDelayFactor:0,directTxDelayFactor:0,trafficIntensity:0,directNeighborCount:(null==t?void 0:t.neighborCount)??0,collisionRisk:0,confidence:0,insufficientData:!0,networkRole:"edge",rationale:"Insufficient data (<100 packets observed)",adjustment:"stable",avgPathPosition:0,pathPositionVariance:0,floodParticipationRate:0,pathDiversity:0,positionDelayMs:0,observationSymmetry:(null==t?void 0:t.avgSymmetry)??0,dataConfidence:"insufficient"});continue}const o=S.get(P),n=w.get(P)??i(o.rawFloodDelay),s=i(.28*n),c=a(n),u=a(s);let l,f={backbone:`Backbone: ${t.neighborCount} neighbors, ${Math.round(100*t.avgSymmetry)}% symmetric`,hub:`Hub: ${t.neighborCount} neighbors`,relay:`Relay: ${Math.round(100*t.avgSymmetry)}% symmetric traffic`,edge:"Edge node"}[o.networkRole];o.observationSymmetry>=.6?f+=". High bidirectional visibility (+1 slot)":o.observationSymmetry<.3&&(f+=". ⚠️ Low symmetry (possible observer bias)"),"low"===o.dataConfidence&&(f+=". Limited data"),l=c>a(1)?"increase":c<a(1)?"decrease":"stable";const h=0;r.set(P,{floodFactor:n,directFactor:s,floodSlots:c,directSlots:u,floodDelaySec:n,directDelaySec:s,txDelayFactor:n,directTxDelayFactor:s,trafficIntensity:Math.round(10*o.trafficIntensity)/10,directNeighborCount:t.neighborCount,collisionRisk:Math.round(100*o.collisionRisk)/100,confidence:o.confidence,insufficientData:!1,networkRole:o.networkRole,rationale:f,adjustment:l,avgPathPosition:Math.round(10*o.avgPathPosition)/10,pathPositionVariance:Math.round(100*o.pathPositionVariance)/100,floodParticipationRate:Math.round(100*o.floodParticipationRate)/100,pathDiversity:o.pathDiversity,positionDelayMs:h,observationSymmetry:Math.round(100*o.observationSymmetry)/100,dataConfidence:o.dataConfidence})}return r}(z,0,x,oe),se=function(e,t){const o=new Map,s=new Map(t.map(e=>[e.key,e]));for(const n of t)o.set(n.key,0);if(0===e.paths.length)return o;for(const i of e.paths)for(let e=0;e<i.hops.length-1;e++){const s=i.hops[e],r=i.hops[e+1];for(const e of t){const t=n(e.fromHash),a=n(e.toHash);if(t===s&&a===r||t===r&&a===s){const t=o.get(e.key)||0;o.set(e.key,t+i.observationCount);break}}}const r=Math.max(...o.values(),1);for(const[n,i]of o)o.set(n,i/r);for(const[n,i]of o){const e=s.get(n);if(e){const t=.5+.5*e.symmetryRatio;o.set(n,i*t)}}return o}(oe,z),re=function(e,t=3,o=.3){return[...e.entries()].filter(([,e])=>e>=o).sort((e,t)=>t[1]-e[1]).slice(0,t).map(([e])=>e)}(se,3,.3),{nodeMobility:ie,mobileNodes:ae}=function(e,t){const o=new Map,n=[];if(0===e.paths.length)return{nodeMobility:o,mobileNodes:n};const s=36e5,r=e.paths.map(e=>e.lastSeen).sort((e,t)=>e-t),i=r[0],a=r[r.length-1],c=Math.ceil((a-i)/s)||1,u=new Map;for(const l of e.paths){const e=Math.floor((l.lastSeen-i)/s);for(const o of l.hops){let n=o;for(const[e]of Object.entries(t))if((e.startsWith("0x")?e.slice(2,4).toUpperCase():e.slice(0,2).toUpperCase())===o.toUpperCase()){n=e;break}let s=u.get(n);s||(s={paths:new Set,firstSeen:l.firstSeen,lastSeen:l.lastSeen,windowPresence:new Set},u.set(n,s)),s.paths.add(l.id),s.firstSeen=Math.min(s.firstSeen,l.firstSeen),s.lastSeen=Math.max(s.lastSeen,l.lastSeen),s.windowPresence.add(e)}}for(const[l,f]of u){const e=f.paths.size,t=f.lastSeen-f.firstSeen,s=t>0?t/36e5:0,r=c>0?f.windowPresence.size/c:1,i=(1-r)*(1-.5*Math.min(e/10,1)),a=i>.3,u={hash:l,pathVolatility:i,pathDiversity:e,avgPathLifespanHours:s,isMobile:a,lastSeen:f.lastSeen,activeWindowRatio:r};o.set(l,u),a&&n.push(l)}return n.sort((e,t)=>{var n,s;const r=(null==(n=o.get(e))?void 0:n.pathVolatility)??0;return((null==(s=o.get(t))?void 0:s.pathVolatility)??0)-r}),{nodeMobility:o,mobileNodes:n}}(oe,b),ce=function(e,t,o,s=20){const r=[];if(0===e.paths.length)return r;const i=new Map;for(const f of t){const e=n(f.fromHash),t=n(f.toHash);i.set(`${e}>${t}`,f),i.set(`${t}>${e}`,f)}const a=new Set;for(const f of o)a.add(n(f));const c=new Map;for(const n of e.paths){if(0===n.hops.length)continue;const e=n.hops[n.hops.length-1],t=c.get(e)||[];t.push(n.id),c.set(e,t)}const u=[...e.paths].sort((e,t)=>t.observationCount-e.observationCount),l=Date.now();for(const n of u.slice(0,s)){if(n.hops.length<2)continue;let e=0,t=1/0,o=null,s=0,u=!1;for(let r=0;r<n.hops.length-1;r++){const c=n.hops[r],l=n.hops[r+1],f=`${c}>${l}`,h=i.get(f);if(h){const n=h.packetCount>0?h.certainCount/h.packetCount:0;e+=n,s++,n<t&&(t=n,o=h.key)}else e+=.1,s++,.1<t&&(t=.1,o=y(c,l));(a.has(c)||a.has(l))&&(u=!0)}const f=s>0?e/s:0,h=t===1/0?0:t,d=(l-n.lastSeen)/36e5,p=Math.exp(-d/24),g=n.observationCount>10&&d<12?.5+.5*(1-d/12):d>48?-.5:0,m=n.hops[n.hops.length-1],C=c.get(m)||[],b=Math.max(0,C.length-1),v="direct"===n.routeType?20:30,S=n.hops.length*v,M=.4*f,w=.3*p,P=(g+1)/2*.15,x=.15*Math.min(b/3,1),E=Math.round(100*(M+w+P+x))/100;r.push({pathKey:n.id,hops:[...n.hops],healthScore:E,weakestLinkKey:o,weakestLinkConfidence:Math.round(100*h)/100,avgEdgeCertainty:Math.round(100*f)/100,observationTrend:Math.round(100*g)/100,alternatePathsCount:b,estimatedLatencyMs:S,observationCount:n.observationCount,routeType:"unknown"===n.routeType?"mixed":n.routeType,lastSeen:n.lastSeen,involvesHub:u})}return r.sort((e,t)=>t.healthScore-e.healthScore),r}(oe,z,q,20),ue=[];for(const e of L.values()){let t=null,o=0,n=0;for(const[s,r]of e.resolvedHashes){if(s===v)continue;const e=r.count>0?r.confidenceSum/r.count:0,i=r.count*e;i>o&&(o=i,t=s,n=e)}t&&ue.push({hash:t,prefix:e.prefix,count:e.count,confidence:n,avgRssi:e.rssiCount>0?e.rssiSum/e.rssiCount:null,avgSnr:e.snrCount>0?e.snrSum/e.snrCount:null,lastSeen:e.lastSeen})}ue.sort((e,t)=>t.count-e.count);let le=0,fe=0;const he=[],de=[];let pe=0;for(const[e,t]of E){le+=t.confidence;const o=t.candidates.length;if(!t.isUnambiguous){fe++;const n=t.candidates.map(e=>e.hash);de.push({prefix:e,candidateCount:o,candidateHashes:n}),t.confidence<.5&&he.push(e)}for(const t of k.values())if(t.hash.toUpperCase().startsWith(e)||t.hash.slice(2).toUpperCase().startsWith(e)){pe+=t.resolutionCount;break}}de.sort((e,t)=>t.candidateCount-e.candidateCount);const ge=de.slice(0,5);return{edges:z,validatedEdges:Y,weakEdges:Q,certainEdges:Y,uncertainEdges:[],edgeMap:Z,maxPacketCount:B,maxCertainCount:K,neighborAffinity:H,fullAffinity:k,localPrefix:_,centrality:N,hubNodes:q,gatewayNodes:G,loops:ee,loopEdgeKeys:te,txDelayRecommendations:ne,pathRegistry:oe,edgeBetweenness:se,backboneEdges:re,nodeMobility:ie,mobileNodes:ae,pathHealth:ce,lastHopNeighbors:ue,disambiguationStats:{totalPrefixes:E.size,unambiguousPrefixes:E.size-fe,collisionPrefixes:fe,collisionRate:E.size>0?Math.round(fe/E.size*1e3)/10:0,avgConfidence:E.size>0?Math.round(le/E.size*1e3)/1e3:0,lowConfidencePrefixes:he,highCollisionPrefixes:ge,totalResolutions:pe}}}var b,v,S={exports:{}},M={};v||(v=1,S.exports=function(){if(b)return M;b=1;var e=Symbol.for("react.element"),t=Symbol.for("react.portal"),o=Symbol.for("react.fragment"),n=Symbol.for("react.strict_mode"),s=Symbol.for("react.profiler"),r=Symbol.for("react.provider"),i=Symbol.for("react.context"),a=Symbol.for("react.forward_ref"),c=Symbol.for("react.suspense"),u=Symbol.for("react.memo"),l=Symbol.for("react.lazy"),f=Symbol.iterator,h={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},d=Object.assign,p={};function g(e,t,o){this.props=e,this.context=t,this.refs=p,this.updater=o||h}function m(){}function y(e,t,o){this.props=e,this.context=t,this.refs=p,this.updater=o||h}g.prototype.isReactComponent={},g.prototype.setState=function(e,t){if("object"!=typeof e&&"function"!=typeof e&&null!=e)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")},g.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},m.prototype=g.prototype;var C=y.prototype=new m;C.constructor=y,d(C,g.prototype),C.isPureReactComponent=!0;var v=Array.isArray,S=Object.prototype.hasOwnProperty,w={current:null},P={key:!0,ref:!0,__self:!0,__source:!0};function x(t,o,n){var s,r={},i=null,a=null;if(null!=o)for(s in void 0!==o.ref&&(a=o.ref),void 0!==o.key&&(i=""+o.key),o)S.call(o,s)&&!P.hasOwnProperty(s)&&(r[s]=o[s]);var c=arguments.length-2;if(1===c)r.children=n;else if(1<c){for(var u=Array(c),l=0;l<c;l++)u[l]=arguments[l+2];r.children=u}if(t&&t.defaultProps)for(s in c=t.defaultProps)void 0===r[s]&&(r[s]=c[s]);return{$$typeof:e,type:t,key:i,ref:a,props:r,_owner:w.current}}function E(t){return"object"==typeof t&&null!==t&&t.$$typeof===e}var k=/\/+/g;function _(e,t){return"object"==typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,function(e){return t[e]})}(""+e.key):t.toString(36)}function H(o,n,s,r,i){var a=typeof o;"undefined"!==a&&"boolean"!==a||(o=null);var c=!1;if(null===o)c=!0;else switch(a){case"string":case"number":c=!0;break;case"object":switch(o.$$typeof){case e:case t:c=!0}}if(c)return i=i(c=o),o=""===r?"."+_(c,0):r,v(i)?(s="",null!=o&&(s=o.replace(k,"$&/")+"/"),H(i,n,s,"",function(e){return e})):null!=i&&(E(i)&&(i=function(t,o){return{$$typeof:e,type:t.type,key:o,ref:t.ref,props:t.props,_owner:t._owner}}(i,s+(!i.key||c&&c.key===i.key?"":(""+i.key).replace(k,"$&/")+"/")+o)),n.push(i)),1;if(c=0,r=""===r?".":r+":",v(o))for(var u=0;u<o.length;u++){var l=r+_(a=o[u],u);c+=H(a,n,s,l,i)}else if(l=function(e){return null===e||"object"!=typeof e?null:"function"==typeof(e=f&&e[f]||e["@@iterator"])?e:null}(o),"function"==typeof l)for(o=l.call(o),u=0;!(a=o.next()).done;)c+=H(a=a.value,n,s,l=r+_(a,u++),i);else if("object"===a)throw n=String(o),Error("Objects are not valid as a React child (found: "+("[object Object]"===n?"object with keys {"+Object.keys(o).join(", ")+"}":n)+"). If you meant to render a collection of children, use an array instead.");return c}function R(e,t,o){if(null==e)return e;var n=[],s=0;return H(e,n,"","",function(e){return t.call(o,e,s++)}),n}function D(e){if(-1===e._status){var t=e._result;(t=t()).then(function(t){0!==e._status&&-1!==e._status||(e._status=1,e._result=t)},function(t){0!==e._status&&-1!==e._status||(e._status=2,e._result=t)}),-1===e._status&&(e._status=0,e._result=t)}if(1===e._status)return e._result.default;throw e._result}var j={current:null},A={transition:null},L={ReactCurrentDispatcher:j,ReactCurrentBatchConfig:A,ReactCurrentOwner:w};function $(){throw Error("act(...) is not supported in production builds of React.")}return M.Children={map:R,forEach:function(e,t,o){R(e,function(){t.apply(this,arguments)},o)},count:function(e){var t=0;return R(e,function(){t++}),t},toArray:function(e){return R(e,function(e){return e})||[]},only:function(e){if(!E(e))throw Error("React.Children.only expected to receive a single React element child.");return e}},M.Component=g,M.Fragment=o,M.Profiler=s,M.PureComponent=y,M.StrictMode=n,M.Suspense=c,M.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=L,M.act=$,M.cloneElement=function(t,o,n){if(null==t)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+t+".");var s=d({},t.props),r=t.key,i=t.ref,a=t._owner;if(null!=o){if(void 0!==o.ref&&(i=o.ref,a=w.current),void 0!==o.key&&(r=""+o.key),t.type&&t.type.defaultProps)var c=t.type.defaultProps;for(u in o)S.call(o,u)&&!P.hasOwnProperty(u)&&(s[u]=void 0===o[u]&&void 0!==c?c[u]:o[u])}var u=arguments.length-2;if(1===u)s.children=n;else if(1<u){c=Array(u);for(var l=0;l<u;l++)c[l]=arguments[l+2];s.children=c}return{$$typeof:e,type:t.type,key:r,ref:i,props:s,_owner:a}},M.createContext=function(e){return(e={$$typeof:i,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:r,_context:e},e.Consumer=e},M.createElement=x,M.createFactory=function(e){var t=x.bind(null,e);return t.type=e,t},M.createRef=function(){return{current:null}},M.forwardRef=function(e){return{$$typeof:a,render:e}},M.isValidElement=E,M.lazy=function(e){return{$$typeof:l,_payload:{_status:-1,_result:e},_init:D}},M.memo=function(e,t){return{$$typeof:u,type:e,compare:void 0===t?null:t}},M.startTransition=function(e){var t=A.transition;A.transition={};try{e()}finally{A.transition=t}},M.unstable_act=$,M.useCallback=function(e,t){return j.current.useCallback(e,t)},M.useContext=function(e){return j.current.useContext(e)},M.useDebugValue=function(){},M.useDeferredValue=function(e){return j.current.useDeferredValue(e)},M.useEffect=function(e,t){return j.current.useEffect(e,t)},M.useId=function(){return j.current.useId()},M.useImperativeHandle=function(e,t,o){return j.current.useImperativeHandle(e,t,o)},M.useInsertionEffect=function(e,t){return j.current.useInsertionEffect(e,t)},M.useLayoutEffect=function(e,t){return j.current.useLayoutEffect(e,t)},M.useMemo=function(e,t){return j.current.useMemo(e,t)},M.useReducer=function(e,t,o){return j.current.useReducer(e,t,o)},M.useRef=function(e){return j.current.useRef(e)},M.useState=function(e){return j.current.useState(e)},M.useSyncExternalStore=function(e,t,o){return j.current.useSyncExternalStore(e,t,o)},M.useTransition=function(){return j.current.useTransition()},M.version="18.3.1",M}()),S.exports,self.onmessage=e=>{const{type:t,payload:o}=e.data;if("compute"!==t)return void self.postMessage({type:"error",error:`Unknown message type: ${t}`});const n=performance.now();try{const{packets:e,neighbors:t,localHash:r,localLat:i,localLon:a,airtimeMs:c}=o,u=C(e,t,r,.5,i,a),l={type:"result",payload:{edges:u.edges,validatedEdges:u.validatedEdges,weakEdges:u.weakEdges,certainEdges:u.certainEdges,uncertainEdges:u.uncertainEdges,maxPacketCount:u.maxPacketCount,maxCertainCount:u.maxCertainCount,localPrefix:u.localPrefix,hubNodes:u.hubNodes,gatewayNodes:u.gatewayNodes,edgeMapEntries:Array.from(u.edgeMap.entries()),neighborAffinityEntries:Array.from(u.neighborAffinity.entries()),fullAffinityEntries:Array.from(u.fullAffinity.entries()),centralityEntries:Array.from(u.centrality.entries()),loops:u.loops,loopEdgeKeyEntries:Array.from(u.loopEdgeKeys),txDelayRecommendationEntries:Array.from(u.txDelayRecommendations.entries()),pathRegistry:(s=u.pathRegistry,{paths:s.paths,byEndpointsEntries:Array.from(s.byEndpoints.entries()),canonicalPathsEntries:Array.from(s.canonicalPaths.entries()),totalObservations:s.totalObservations,uniquePathCount:s.uniquePathCount}),edgeBetweennessEntries:Array.from(u.edgeBetweenness.entries()),backboneEdges:u.backboneEdges,nodeMobilityEntries:Array.from(u.nodeMobility.entries()),mobileNodes:u.mobileNodes,pathHealth:u.pathHealth,lastHopNeighbors:u.lastHopNeighbors,disambiguationStats:u.disambiguationStats},computeTimeMs:performance.now()-n};self.postMessage(l)}catch(r){const e={type:"error",error:r instanceof Error?r.message:"Unknown error in topology worker"};self.postMessage(e)}var s}}();
