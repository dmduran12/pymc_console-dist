var t=Object.defineProperty,s=(s,e,a)=>((s,e,a)=>e in s?t(s,e,{enumerable:!0,configurable:!0,writable:!0,value:a}):s[e]=a)(s,"symbol"!=typeof e?e+"":e,a);import{a4 as e,bj as a,bk as r,bl as h,bm as i,af as n,bn as o,bo as p,bp as y,bq as d,br as l,bs as u,bt as g,bb as c,bu as b,bv as T,bw as m,bx as C,by as L,bz as w,bA as f,bB as S,bC as N,bD as $,bE as x,bF as A}from"./index-C00I5uLb.js";class U{constructor(){s(this,"header",0),s(this,"transportCodes",[0,0]),s(this,"pathLen",0),s(this,"path",new Uint8Array(0)),s(this,"payload",new Uint8Array(0)),s(this,"decrypted",{}),s(this,"_rssi",0),s(this,"_snr",0)}static fromBytes(t){const s=new U;try{return s.readFrom(t),{success:!0,packet:s}}catch(e){return{success:!1,error:e instanceof Error?e.message:String(e)}}}static fromHex(t){try{const s=e(t);return U.fromBytes(s)}catch(s){return{success:!1,error:s instanceof Error?s.message:String(s)}}}get routeType(){return this.header&a}get routeTypeName(){return r[this.routeType]??`UNKNOWN(${this.routeType})`}get payloadType(){return this.header>>h&i}get payloadTypeName(){return n[this.payloadType]??`UNKNOWN(${this.payloadType})`}get payloadVersion(){return this.header>>o&p}hasTransportCodes(){return y(this.routeType)}isFlood(){return d(this.routeType)}isDirect(){return l(this.routeType)}get pathBytes(){return Array.from(this.path)}get pathString(){return u(this.path)}get pathHexArray(){return Array.from(this.path).map(t=>g(t,!0))}get payloadLen(){return this.payload.length}get payloadHex(){return c(this.payload,!0)}getPayloadAppData(){const t=$+x+A;return this.payload.length>=t?this.payload.slice(t):new Uint8Array(0)}get rssi(){return this._rssi}set rssi(t){this._rssi=t}get snr(){return this._snr}set snr(t){this._snr=t}readFrom(t){let s=0;const e=t.length;b(s,1,e,"Missing header byte"),this.header=t[s++];const a=this.payloadVersion;if(a>T)throw new Error(`Unsupported packet version: ${a}`);if(this.hasTransportCodes()?(b(s,4,e,"Missing transport codes"),this.transportCodes=[m(t,s),m(t,s+2)],s+=4):this.transportCodes=[0,0],b(s,1,e,"Missing path_len"),this.pathLen=t[s++],this.pathLen>C)throw new Error(`path_len too large: ${this.pathLen} > ${C}`);return b(s,this.pathLen,e,"Truncated path"),this.path=t.slice(s,s+this.pathLen),s+=this.pathLen,this.payload=t.slice(s),L(this.payload.length),!0}writeTo(){let t=1;this.hasTransportCodes()&&(t+=4),t+=1,t+=this.path.length,t+=this.payload.length;const s=new Uint8Array(t);let e=0;return s[e++]=this.header,this.hasTransportCodes()&&(w(this.transportCodes[0],s,e),w(this.transportCodes[1],s,e+2),e+=4),s[e++]=this.path.length,s.set(this.path,e),e+=this.path.length,s.set(this.payload,e),s}toHex(){return c(this.writeTo(),!0)}async calculateHash(){return f(this.payloadType,this.pathLen,this.payload)}async calculateHashString(t){return S(this.payloadType,this.pathLen,this.payload,t)}async calculateCRC(){return N(this.payloadType,this.pathLen,this.payload)}getRawLength(){let t=2+this.pathLen+this.payload.length;return this.hasTransportCodes()&&(t+=4),t}getSummary(){return{header:g(this.header,!0),routeType:this.routeTypeName,payloadType:this.payloadTypeName,version:this.payloadVersion,pathLen:this.pathLen,pathStr:this.pathString,transportCodes:this.hasTransportCodes()?[this.transportCodes[0].toString(16).toUpperCase().padStart(4,"0"),this.transportCodes[1].toString(16).toUpperCase().padStart(4,"0")]:null,payloadLen:this.payload.length,payloadHex:this.payloadHex,rawLength:this.getRawLength()}}toString(){const t=[`[${this.routeTypeName}/${this.payloadTypeName} v${this.payloadVersion}]`,`path=${this.pathString||"(empty)"}`,`payload=${this.payload.length}B`];return this.hasTransportCodes()&&t.push(`transport=[${this.transportCodes[0]},${this.transportCodes[1]}]`),t.join(" ")}}export{U as P};
