var hi=Object.defineProperty;var pi=(bt,St,Nt)=>St in bt?hi(bt,St,{enumerable:!0,configurable:!0,writable:!0,value:Nt}):bt[St]=Nt;var on=(bt,St,Nt)=>pi(bt,typeof St!="symbol"?St+"":St,Nt);(function(){"use strict";const xt={TRANSPORT_FLOOD:0,FLOOD:1,DIRECT:2,TRANSPORT_DIRECT:3},sn={TRACE:9};function le(t){return t===xt.FLOOD||t===xt.TRANSPORT_FLOOD}function de(t){return t===xt.DIRECT||t===xt.TRANSPORT_DIRECT}function ct(t){return t.startsWith("0x")||t.startsWith("0X")?t.slice(2,4).toUpperCase():t.slice(0,2).toUpperCase()}function kt(t,e){let n=t.forwarded_path??t.original_path;if(typeof n=="string")try{n=JSON.parse(n)}catch{return null}if(!n||!Array.isArray(n)||n.length===0)return null;const o=n.map(c=>String(c).toUpperCase()),s=e?ct(e):null,i=o[o.length-1],a=s!==null&&i===s,r=a?o.slice(0,-1):[...o];return{effective:r,original:o,hadLocal:a,effectiveLength:r.length}}function Xt(t,e){return e-t}function Di(t){return t}const mt={VERY_CLOSE:500,CLOSE:2e3,MEDIUM:5e3,FAR:1e4,VERY_FAR:2e4},Tt={VERY_CLOSE:1,CLOSE:.8,MEDIUM:.6,FAR:.4,VERY_FAR:.2,BEYOND:.1};function vt(t,e,n,o){const i=(n-t)*Math.PI/180,a=(o-e)*Math.PI/180,r=Math.sin(i/2)*Math.sin(i/2)+Math.cos(t*Math.PI/180)*Math.cos(n*Math.PI/180)*Math.sin(a/2)*Math.sin(a/2);return 6371e3*(2*Math.atan2(Math.sqrt(r),Math.sqrt(1-r)))}function rn(t){return t<mt.VERY_CLOSE?Tt.VERY_CLOSE:t<mt.CLOSE?Tt.CLOSE:t<mt.MEDIUM?Tt.MEDIUM:t<mt.FAR?Tt.FAR:t<mt.VERY_FAR?Tt.VERY_FAR:Tt.BEYOND}function cn(t,e){return t!==void 0&&e!==void 0&&(t!==0||e!==0)}function an(t){if(t.contact_type){const e=t.contact_type.toLowerCase();if(e==="repeater"||e==="rep")return!0;if(e==="companion"||e==="client"||e==="cli"||e==="room server"||e==="room_server"||e==="room"||e==="server")return!1}return t.is_repeater===!0?!0:(t.is_repeater===!1,!1)}function un(t){const e={};for(const[n,o]of Object.entries(t))an(o)&&(e[n]=o);return e}const Lt={position:.15,cooccurrence:.15,geographic:.35,recency:.35},Pt=5,fn=336,ln=12,dn=168,hn=72;function pn(t,e){if(!t||t<=0)return .1;const o=(Math.floor(Date.now()/1e3)-t)/3600;return o<0?1:Math.exp(-o/ln)}function gn(t){return!t||t<=0?!1:(Math.floor(Date.now()/1e3)-t)/3600>fn}function mn(t,e,n,o,s){const i=new Map,a=un(e),r=new Map,c=o!==void 0&&s!==void 0&&(o!==0||s!==0);if(n){const h=ct(n),d={hash:n,prefix:h,positionCounts:new Array(Pt).fill(0),totalAppearances:0,typicalPosition:0,positionConsistency:0,adjacentPrefixCounts:new Map,totalAdjacentObservations:0,latitude:o,longitude:s,distanceToLocal:0,srcGeoEvidenceScore:0,srcGeoEvidenceCount:0,lastSeenTimestamp:Math.floor(Date.now()/1e3),recencyScore:1,positionScore:0,cooccurrenceScore:0,geographicScore:1,combinedScore:0};r.set(h,[d])}for(const[h,d]of Object.entries(a)){const p=ct(h),E=d.last_seen??0;if(gn(E))continue;let S;const v=d.zero_hop===!0;c&&d.latitude&&d.longitude&&(d.latitude!==0||d.longitude!==0)&&(S=vt(o,s,d.latitude,d.longitude));let f=.2;S!==void 0?S<mt.VERY_CLOSE?f=1:S<mt.CLOSE?f=.8:S<mt.MEDIUM?f=.6:S<mt.FAR?f=.4:S<mt.VERY_FAR?f=.2:f=.1:d.latitude&&d.longitude&&(f=.5);const _=pn(E);if(v&&_>.01){const L=E>0?(Math.floor(Date.now()/1e3)-E)/3600:1/0,M=Math.exp(-L/hn);f=Math.max(f,.95*M)}const C={hash:h,prefix:p,name:d.name||d.node_name,positionCounts:new Array(Pt).fill(0),totalAppearances:0,typicalPosition:0,positionConsistency:0,adjacentPrefixCounts:new Map,totalAdjacentObservations:0,latitude:d.latitude,longitude:d.longitude,distanceToLocal:S,srcGeoEvidenceScore:0,srcGeoEvidenceCount:0,lastSeenTimestamp:E,recencyScore:_,positionScore:0,cooccurrenceScore:0,geographicScore:f,combinedScore:0},b=r.get(p)||[];b.push(C),r.set(p,b)}for(const h of t){const d=kt(h,n);if(!d||d.effectiveLength===0)continue;const p=d.effective,E=h.src_hash,S=E?e[E]:void 0,v=(S==null?void 0:S.latitude)&&(S==null?void 0:S.longitude)&&(S.latitude!==0||S.longitude!==0);for(let f=0;f<p.length;f++){const _=p[f],C=r.get(_);if(!C)continue;const b=Xt(f,d.effectiveLength),L=Math.min(b-1,Pt-1);for(const M of C){if(M.positionCounts[L]++,M.totalAppearances++,b===1&&C.length>1&&v&&M.latitude&&M.longitude){const T=vt(S.latitude,S.longitude,M.latitude,M.longitude);let O=0;T<500?O=1:T<2e3?O=.8:T<5e3?O=.5:T<1e4?O=.3:O=.1,M.distanceToLocal!==void 0&&(M.distanceToLocal<500?O*=1.2:M.distanceToLocal<2e3?O*=1:O*=.8),M.srcGeoEvidenceScore+=O,M.srcGeoEvidenceCount++}if(f>0&&C.length>1&&M.latitude&&M.longitude){const T=f-1,O=p[T],I=r.get(O);if(I&&I.length>0){let F,x,G=0;if(I.length===1){const N=I[0];N.latitude&&N.longitude&&(F=N.latitude,x=N.longitude,G=1)}else{const N=[...I].sort((H,$)=>$.combinedScore-H.combinedScore),y=N[0],k=N[1];if(y.latitude&&y.longitude&&y.combinedScore>0){const H=k?(y.combinedScore-k.combinedScore)/y.combinedScore:1;G=Math.min(1,H+.3),G>.4&&(F=y.latitude,x=y.longitude)}}if(F!==void 0&&x!==void 0){const N=vt(M.latitude,M.longitude,F,x);let y=0;N<500?y=1:N<2e3?y=.8:N<5e3?y=.5:N<1e4?y=.3:y=.1,y*=G,M.srcGeoEvidenceScore+=y,M.srcGeoEvidenceCount++}}}if(b>1&&C.length>1&&M.latitude&&M.longitude){const T=f+1;if(T<p.length){const O=p[T],I=r.get(O);if(I&&I.length>0){let F,x,G=0;if(I.length===1){const N=I[0];N.latitude&&N.longitude&&(F=N.latitude,x=N.longitude,G=1)}else{const N=[...I].sort((H,$)=>$.combinedScore-H.combinedScore),y=N[0],k=N[1];if(y.latitude&&y.longitude&&y.combinedScore>0){const H=k?(y.combinedScore-k.combinedScore)/y.combinedScore:1;G=Math.min(1,H+.3),G>.4&&(F=y.latitude,x=y.longitude)}}if(F!==void 0&&x!==void 0){const N=vt(M.latitude,M.longitude,F,x);let y=0;N<500?y=1:N<2e3?y=.8:N<5e3?y=.5:N<1e4?y=.3:y=.1,y*=G,M.srcGeoEvidenceScore+=y,M.srcGeoEvidenceCount++}}}}if(f>0){const T=p[f-1];M.adjacentPrefixCounts.set(T,(M.adjacentPrefixCounts.get(T)||0)+1),M.totalAdjacentObservations++}if(f<p.length-1){const T=p[f+1];M.adjacentPrefixCounts.set(T,(M.adjacentPrefixCounts.get(T)||0)+1),M.totalAdjacentObservations++}}}}let l=1,g=1;for(const h of r.values())for(const d of h)l=Math.max(l,d.totalAppearances),g=Math.max(g,d.totalAdjacentObservations);for(const h of r.values())for(const d of h){if(d.totalAppearances>0){let p=0,E=1;for(let v=0;v<Pt;v++)d.positionCounts[v]>p&&(p=d.positionCounts[v],E=v+1);d.typicalPosition=E,d.positionConsistency=p/d.totalAppearances;const S=d.totalAppearances/l;d.positionScore=d.positionConsistency*.6+S*.4}if(d.totalAdjacentObservations>0&&(d.cooccurrenceScore=d.totalAdjacentObservations/g),d.combinedScore=d.positionScore*Lt.position+d.cooccurrenceScore*Lt.cooccurrence+d.geographicScore*Lt.geographic+d.recencyScore*Lt.recency,d.srcGeoEvidenceCount>0){const p=d.srcGeoEvidenceScore/d.srcGeoEvidenceCount,E=Math.min(d.srcGeoEvidenceCount/50,1),S=p*E*.3;d.combinedScore+=S}}for(const[h,d]of r){d.sort((f,_)=>_.combinedScore-f.combinedScore);const p=d.length>0?d[0].hash:null;let E=0;if(d.length===1)E=1;else if(d.length>1){const f=d[0].combinedScore,_=d[1].combinedScore;f>0&&(E=Math.min(1,(f-_)/f)),d[0].totalAppearances>d[1].totalAppearances*2&&(E=Math.min(1,E+.2));const C=0,b=d[0].positionCounts[C]||0,L=d[1].positionCounts[C]||0,M=b+L;if(M>=20&&b>=10){const x=b/M;if(x>=.8){const G=.3+(x-.8)*1.5;E=Math.min(1,E+G)}}const T=d.reduce((x,G)=>x+G.combinedScore,0);if(T>0){const x=[],G=d.reduce((H,$)=>H+($.positionCounts[0]||0),0);for(const H of d){const $=H.combinedScore/T,Y=G*$;x.push(Y)}const N=x[0],y=x[1]||0,k=N+y;if(k>=20&&N>=10){const H=N/k;if(H>=.6){const $=.2+(H-.6)*1;E=Math.min(1,E+$)}}}const O=d[0].srcGeoEvidenceScore,I=d[1].srcGeoEvidenceScore;if(d[0].srcGeoEvidenceCount>=10&&O>I*1.5){const x=I>0?O/(O+I):1,G=Math.min(.3,(x-.5)*.6);E=Math.min(1,E+G)}}const S=new Map;for(let f=1;f<=Pt;f++){const _=[...d].sort((C,b)=>{const L=C.positionCounts[f-1]||0;return(b.positionCounts[f-1]||0)-L});if(_.length>0&&_[0].positionCounts[f-1]>0){const C=_[0];let b=1;if(_.length>1){const L=C.positionCounts[f-1],M=_[1].positionCounts[f-1]||0,T=L+M;b=T>0?L/T:0}S.set(f,{hash:C.hash,confidence:b})}}const v={prefix:h,candidates:d,bestMatch:p,confidence:E,isUnambiguous:d.length===1,bestMatchForPosition:S};i.set(h,v)}return i}function ft(t,e,n){const o=e.toUpperCase(),s=t.get(o);if(!s||s.candidates.length===0)return{hash:null,confidence:0};if(n!=null&&n.isLastHop)return{hash:s.bestMatch,confidence:s.confidence};if((n==null?void 0:n.position)===1)return{hash:s.bestMatch,confidence:s.confidence};if(n!=null&&n.position&&s.bestMatchForPosition.has(n.position)){const i=s.bestMatchForPosition.get(n.position),a=Math.max(i.confidence,s.confidence);return{hash:i.hash,confidence:a}}if(n!=null&&n.adjacentPrefixes&&n.adjacentPrefixes.length>0){let i=s.bestMatch,a=0;for(const r of s.candidates){let c=0;for(const g of n.adjacentPrefixes)c+=r.adjacentPrefixCounts.get(g.toUpperCase())||0;const l=r.combinedScore+c/Math.max(1,r.totalAdjacentObservations)*.3;l>a&&(a=l,i=r.hash)}return{hash:i,confidence:s.confidence}}return{hash:s.bestMatch,confidence:s.confidence}}function he(t){return!t||t<=0?!0:(Math.floor(Date.now()/1e3)-t)/3600>dn}function Cn(t){var a;if(t.length<=1)return{isReplacement:!1,activeCandidates:t,staleReplacements:[]};const e=new Map,n=[];for(const r of t){const c=(a=r.name)==null?void 0:a.trim().toLowerCase();if(c){const l=e.get(c)||[];l.push(r),e.set(c,l)}else n.push(r)}const o=[],s=[];let i=!1;for(const[,r]of e)if(r.length>1){const c=r.filter(g=>!he(g.lastSeenTimestamp)),l=r.filter(g=>he(g.lastSeenTimestamp));if(c.length>=1&&l.length>=1){i=!0,c.sort((g,h)=>h.recencyScore-g.recencyScore),o.push(c[0]),s.push(...l);for(let g=1;g<c.length;g++)o.push(c[g])}else o.push(...r)}else o.push(...r);return o.push(...n),{isReplacement:i,activeCandidates:o,staleReplacements:s}}function zt(t){return t.type==="known"}const yn=150,Sn=.5,Qt=10,En=915,_n=299792458,Mn=.6,pe=[0,.25,.5,.75,1];function Zt(t,e,n){if(!t)return 0;const o=(n-t.origin[1])/t.cellSize,s=(e-t.origin[0])/t.cellSize;if(o<0||o>=t.width-1||s<0||s>=t.height-1)return 0;const i=Math.floor(o),a=Math.floor(s),r=o-i,c=s-a,l=a*t.width+i,g=a*t.width+i+1,h=(a+1)*t.width+i,d=(a+1)*t.width+i+1,p=t.elevations[l]??0,E=t.elevations[g]??0,S=t.elevations[h]??0,v=t.elevations[d]??0,f=p*(1-r)+E*r,_=S*(1-r)+v*r;return f*(1-c)+_*c}function vn(t,e,n,o,s){const i=t+(n-t)*s,a=e+(o-e)*s;return[i,a]}function bn(t,e,n,o){const s=t+(e-t)*n,i=Math.abs(n-.5)*2,r=Rt(o)*(1-i*i);return s-r}function Tn(t,e,n=En){const o=_n/(n*1e6),s=t*1e3,i=(e-t)*1e3;return s<=0||i<=0?0:Math.sqrt(o*s*i/(s+i))}function ge(t,e,n){const o=t.latitude!==void 0&&t.longitude!==void 0&&(t.latitude!==0||t.longitude!==0),s=e.latitude!==void 0&&e.longitude!==void 0&&(e.latitude!==0||e.longitude!==0);if(!o||!s)return{theoreticallyPossible:!0,losConfidence:.3,worstClearance:0,sampleCount:0,reason:"no_terrain",distanceKm:0,earthBulgeM:0};const i=Gt(t.latitude,t.longitude,e.latitude,e.longitude);if(i>yn)return{theoreticallyPossible:!1,losConfidence:1,worstClearance:-1/0,sampleCount:0,reason:"distance_limit",distanceKm:i,earthBulgeM:Rt(i)};if(i<Sn)return{theoreticallyPossible:!0,losConfidence:.95,worstClearance:100,sampleCount:0,reason:"too_close",distanceKm:i,earthBulgeM:Rt(i)};if(!n){const p=Rt(i),E=Qt*2-p;return{theoreticallyPossible:E>0||i<30,losConfidence:.4,worstClearance:E,sampleCount:0,reason:E>10?"likely_clear":"marginal",distanceKm:i,earthBulgeM:p}}const a=t.elevation??Zt(n,t.latitude,t.longitude),r=e.elevation??Zt(n,e.latitude,e.longitude),c=a+(t.antennaHeight??Qt),l=r+(e.antennaHeight??Qt);let g=1/0,h=1;for(const p of pe){const[E,S]=vn(t.latitude,t.longitude,e.latitude,e.longitude,p),v=Zt(n,E,S),_=bn(c,l,p,i)-v;if(_<g){g=_;const b=Tn(p*i,i)*Mn;h=_/b}}const d=Rn(g,h,i);return{theoreticallyPossible:d!=="blocked"&&d!=="distance_limit",losConfidence:.7,worstClearance:g,sampleCount:pe.length,reason:d,distanceKm:i,earthBulgeM:Rt(i)}}function Rn(t,e,n){return t>20&&e>1?"clear":t>5&&e>.6?"likely_clear":t>-5&&e>.3?"marginal":t>-20||n<10?"likely_blocked":"blocked"}function On(t){switch(t){case"clear":case"likely_clear":case"too_close":return{minCount:0,minConfidence:0};case"marginal":return{minCount:5,minConfidence:.6};case"likely_blocked":return{minCount:10,minConfidence:.7};case"blocked":return{minCount:20,minConfidence:.8};case"distance_limit":return{minCount:1/0,minConfidence:1};case"no_terrain":return{minCount:3,minConfidence:.5};default:return{minCount:10,minConfidence:.7}}}function Ft(t){const{terrainFeasibility:e,observationCount:n,observationConfidence:o}=t;if(e.theoreticallyPossible)return!0;const s=On(e.reason);return e.reason==="distance_limit"?!1:n>=s.minCount&&o>=s.minConfidence}function Hn(t){return{terrainFeasibility:t,observationCount:0,observationConfidence:0,lastObserved:0,isOverridden:!1}}function wn(t,e,n){const o=t.observationCount+1,s=(t.observationConfidence*t.observationCount+e)/o,i={...t,observationCount:o,observationConfidence:s,lastObserved:Math.max(t.lastObserved,n)};return i.isOverridden=!t.terrainFeasibility.theoreticallyPossible&&Ft(i),i}function Jt(t,e){return t<e?`${t}|${e}`:`${e}|${t}`}class Nn{constructor(){on(this,"cache",new Map)}getOrCompute(e,n,o){const s=Jt(e.hash,n.hash);let i=this.cache.get(s);if(!i){const a=ge(e,n,o);i=Hn(a),this.cache.set(s,i)}return i}recordObservation(e,n,o,s){const i=Jt(e,n),a=this.cache.get(i);if(a){const r=wn(a,o,s);return this.cache.set(i,r),r}}get(e,n){return this.cache.get(Jt(e,n))}isFeasible(e,n){const o=this.get(e,n);return o?Ft(o):!0}getOverriddenLinks(){const e=[];for(const[n,o]of this.cache)o.isOverridden&&e.push({key:n,evidence:o});return e}clear(){this.cache.clear()}getStats(){let e=0,n=0,o=0;for(const s of this.cache.values())Ft(s)?(e++,s.isOverridden&&o++):n++;return{totalLinks:this.cache.size,possibleLinks:e,blockedLinks:n,overriddenLinks:o}}}const me=6371,Pn=150,In=60,An=.15,Dn=40,xn=.5,kn=15,Ln=1e-10,Fn=1e3;function Gt(t,e,n,o){const s=t*Math.PI/180,i=e*Math.PI/180,a=n*Math.PI/180,r=o*Math.PI/180,c=a-s,l=r-i,g=Math.sin(c/2)**2+Math.cos(s)*Math.cos(a)*Math.sin(l/2)**2,h=2*Math.atan2(Math.sqrt(g),Math.sqrt(1-g));return me*h}function Rt(t){if(t<=0)return 0;const e=me*1e3,n=t*1e3;return n*n/(8*e)}function Gn(t){return 1/(1+Math.exp(An*(t-In)))}function Un(t){return 1/(1+Math.exp(xn*(t-Dn)))}function $n(t,e,n,o){const s=Gt(t,e,n,o);if(s>Pn)return 1/0;if(s<.1)return .01;const i=Rt(s),a=Gn(s),r=Un(i),c=a*r;return c<Ln?Fn:-Math.log(c)}function Ce(t,e){const n=t.latitude!==void 0&&t.longitude!==void 0&&(t.latitude!==0||t.longitude!==0),o=e.latitude!==void 0&&e.longitude!==void 0&&(e.latitude!==0||e.longitude!==0);return!n||!o?3:$n(t.latitude,t.longitude,e.latitude,e.longitude)}function Kn(t){return t===1/0?0:Math.exp(-t)}const Bn=8,Ut=2,Yn=5;function Vn(t,e,n,o){let s,i;if(o?(s=o.terrainFeasibility,i=Ft(o)):(s=ge(t,e,n),i=s.theoreticallyPossible),s.reason==="distance_limit"||!i)return 1/0;const a=Ce({latitude:t.latitude,longitude:t.longitude},{latitude:e.latitude,longitude:e.longitude});let r=0;switch(s.reason){case"clear":case"too_close":r=0;break;case"likely_clear":r=.5;break;case"marginal":r=Ut;break;case"likely_blocked":r=o!=null&&o.isOverridden?Ut:Yn;break;case"blocked":r=o!=null&&o.isOverridden?Ut:Bn;break;case"no_terrain":r=0;break}if(o!=null&&o.isOverridden&&o.observationCount>0){const c=Math.log(1+o.observationCount/10);r=Math.max(0,r-c)}return a+r}function jn(t,e,n,o,s,i){const a=Vn(t,e,n,o);if(a===1/0){if(i>=.8&&s>=20){const r=Math.log(1+s/5);return Math.max(.5,Ut-r)}return 1/0}return ye(a,s,i)}function ye(t,e,n){if(n>=.8&&e>0){const o=Math.log(1+Math.min(e,50)/5);return Math.max(.01,.5-o)}if(n>=.5&&e>0){const o=Math.log(1+e/10);return t*.3+Math.max(.1,t-o)*.7}if(e>0){const o=Math.log(1+e/20);return t*.7+Math.max(.1,t-o)*.3}return t}const Wn=.8,qn=20,Xn=15,zn=12,Qn=5,Zn=.01,Jn=5,Se=2,to=3,eo=5,no=.35,oo=.3;function Ee(t,e){return t<e?`${t}-${e}`:`${e}-${t}`}function so(t){if(t.length===0)return Qn;const e=Math.max(...t.map(n=>n.confidence));return e>=.6?qn:e>=.3?Xn:zn}function io(t,e,n){for(const o of t){const s=o.latitude!==void 0&&o.longitude!==void 0,i=o.recencyScore>=no,a=o.confidence>=oo;if(s&&i&&a)return!0}if(n&&t.length>0&&e.length>0)for(const o of t)for(const s of e){const i=Ee(o.hash,s);if((n.edgeCounts.get(i)??0)>=eo)return!0}return!1}function ro(t,e,n,o=[],s){const i=[];let a=0;for(const c of e){const l=-Math.log(Math.max(c.recencyScore,Zn));let g=Math.min(l,Jn);c.confidence>=.8?g=Math.max(0,g-Se):c.confidence>=.5&&(g=Math.max(0,g-Se*.5)),i.push({stateIdx:a,hash:c.hash,prefix:t,isGhost:!1,latitude:c.latitude,longitude:c.longitude,priorCost:g,disambiguationConfidence:c.confidence}),a++}const r=io(e,o,s);if(n&&!r){const c=so(e);i.push({stateIdx:a,hash:null,prefix:t,isGhost:!0,priorCost:c,disambiguationConfidence:0})}return i}function co(t,e,n){var h,d,p;const o=n.minEdgeObservationsForHistory??to;if(t.isGhost||e.isGhost)return kn;const s=Ee(t.hash,e.hash),i=((h=n.edgeHistory)==null?void 0:h.edgeCounts.get(s))??0,a=((d=n.edgeHistory)==null?void 0:d.edgeConfidence.get(s))??0,r=Math.sqrt(t.disambiguationConfidence*e.disambiguationConfidence),c=i>=o?Math.max(r,a):r;if(n.enableTerrainAware??n.terrainGrid!==void 0){const E={hash:t.hash,latitude:t.latitude,longitude:t.longitude},S={hash:e.hash,latitude:e.latitude,longitude:e.longitude},v=(p=n.feasibilityCache)==null?void 0:p.get(t.hash,e.hash),f=jn(E,S,n.terrainGrid,v,i,c);return n.feasibilityCache&&f!==1/0&&c>.3&&n.feasibilityCache.recordObservation(t.hash,e.hash,c,Date.now()),f}const g=Ce({latitude:t.latitude,longitude:t.longitude},{latitude:e.latitude,longitude:e.longitude});return ye(g,i,c)}function ao(t,e,n={}){const o=n.enableGhostNodes??!0;if(e.length===0)return{nodes:[],totalCost:0,confidence:1,hasGhostNodes:!1,ghostPrefixes:[],originalPrefixes:[],usedObservationOverride:!1};const s=e.length,i=[];for(let f=0;f<s;f++){const _=e[f].toUpperCase();i.push(t.get(_)??[])}const a=[];for(let f=0;f<s;f++){const _=e[f].toUpperCase(),C=i[f],b=[];f>0&&b.push(...i[f-1].map(M=>M.hash)),f<s-1&&b.push(...i[f+1].map(M=>M.hash));const L=ro(_,C,o,b,n.edgeHistory);if(L.length===0)return _e(e);a.push(L)}const r=[];r[0]=a[0].map(f=>({cost:f.priorCost,prevStateIdx:null,state:f}));let c=!1;for(let f=1;f<s;f++){const _=a[f],C=r[f-1];r[f]=_.map(b=>{let L=1/0,M=null;for(let T=0;T<C.length;T++){const O=C[T],I=O.state;if(O.cost===1/0)continue;const F=co(I,b,n);if(!b.isGhost&&!I.isGhost&&Math.sqrt(I.disambiguationConfidence*b.disambiguationConfidence)>=(n.observationOverrideThreshold??Wn)&&(c=!0),F===1/0)continue;const x=O.cost+F+b.priorCost;x<L&&(L=x,M=T)}return{cost:L,prevStateIdx:M,state:b}})}const l=r[s-1];let g=1/0,h=0;for(let f=0;f<l.length;f++)l[f].cost<g&&(g=l[f].cost,h=f);if(g===1/0)return _e(e);const d=[],p=[];let E=h;for(let f=s-1;f>=0;f--){const _=r[f][E],C=_.state;if(C.isGhost){const b={type:"ghost",prefix:C.prefix};d.unshift(b),p.unshift(C.prefix)}else{const b={type:"known",hash:C.hash,prefix:C.prefix,confidence:C.disambiguationConfidence,latitude:C.latitude,longitude:C.longitude};d.unshift(b)}f>0&&_.prevStateIdx!==null&&(E=_.prevStateIdx)}const S=s>0?g/s:g,v=Kn(S);return{nodes:d,totalCost:g,confidence:v,hasGhostNodes:p.length>0,ghostPrefixes:p,originalPrefixes:e,usedObservationOverride:c}}function _e(t){return{nodes:t.map(e=>({type:"ghost",prefix:e.toUpperCase()})),totalCost:1/0,confidence:0,hasGhostNodes:!0,ghostPrefixes:t.map(e=>e.toUpperCase()),originalPrefixes:t,usedObservationOverride:!1}}function uo(t,e,n){if(!t.hasGhostNodes)return[];const o=[];for(let s=0;s<t.nodes.length;s++){const i=t.nodes[s];if(i.type!=="ghost")continue;let a=null,r=null;for(let c=s-1;c>=0;c--)if(t.nodes[c].type==="known"){a=t.nodes[c];break}for(let c=s+1;c<t.nodes.length;c++)if(t.nodes[c].type==="known"){r=t.nodes[c];break}o.push({prefix:i.prefix,beforeNodeHash:(a==null?void 0:a.hash)??null,afterNodeHash:(r==null?void 0:r.hash)??null,beforeLocation:(a==null?void 0:a.latitude)!==void 0&&(a==null?void 0:a.longitude)!==void 0?{lat:a.latitude,lon:a.longitude}:void 0,afterLocation:(r==null?void 0:r.latitude)!==void 0&&(r==null?void 0:r.longitude)!==void 0?{lat:r.latitude,lon:r.longitude}:void 0,timestamp:e,packetHash:n})}return o}function fo(t){const e=new Map;for(const[n,o]of t){const s=o.candidates.map(i=>({hash:i.hash,prefix:i.prefix,latitude:i.latitude,longitude:i.longitude,confidence:i.combinedScore,recencyScore:i.recencyScore}));e.set(n,s)}return e}function lo(t){const e=new Map,n=new Map;for(const[o,s]of t)e.set(o,s.count),n.set(o,s.count>0?s.confidenceSum/s.count:0);return{edgeCounts:e,edgeConfidence:n}}const $t=10,ho=5,po=30,Me=10,go=2,mo=50,Co=.5,yo=500,So=25e3,Eo=50,_o=200,Mo=.5,vo=.7,It=10080*60*1e3,bo=168;function To(t,e){if(!t||t<=0)return .1;const n=t*1e3,s=(e-n)/(1e3*60*60);return s<0?1:Math.exp(-s/bo)}function Ro(t,e){const n=e??Date.now(),o=new Map;for(const i of t){const a=i.prefix.toUpperCase(),r=To(i.timestamp,n),c=o.get(a);c?(c.observations.push(i),c.weightedCount+=r):o.set(a,{observations:[i],weightedCount:r})}const s=[];for(const[i,a]of o){const r=a.observations.length>=$t,c=a.weightedCount>=ho;if(!r&&!c)continue;const l=Oo(i,a.observations,n);l&&s.push(l)}return s.sort((i,a)=>a.confidence-i.confidence),s}function Oo(t,e,n){const o=new Map,s=[];let i=1/0,a=0;for(const p of e)if(p.beforeNodeHash&&o.set(p.beforeNodeHash,(o.get(p.beforeNodeHash)??0)+1),p.afterNodeHash&&o.set(p.afterNodeHash,(o.get(p.afterNodeHash)??0)+1),i=Math.min(i,p.timestamp),a=Math.max(a,p.timestamp),p.beforeLocation&&p.afterLocation){const E=Gt(p.beforeLocation.lat,p.beforeLocation.lon,p.afterLocation.lat,p.afterLocation.lon);if(E>mo)continue;const S=(p.beforeLocation.lat+p.afterLocation.lat)/2,v=(p.beforeLocation.lon+p.afterLocation.lon)/2,f=n-p.timestamp*1e3,_=f<It?1-f/It*.5:.5;s.push({lat:S,lon:v,weight:_,anchorDistanceKm:E})}let r;if(s.length>0){const p=s.reduce((O,I)=>O+I.weight,0),E=s.reduce((O,I)=>O+I.lat*I.weight,0)/p,S=s.reduce((O,I)=>O+I.lon*I.weight,0)/p,v=s.map(O=>O.anchorDistanceKm).sort((O,I)=>O-I),_=v[Math.floor(v.length/2)]*1e3*Co,C=s.map(O=>Gt(E,S,O.lat,O.lon)),L=Math.max(...C)*1e3,M=Math.sqrt(_**2+L**2),T=Math.min(Math.max(M,yo),So);r={lat:E,lon:S,uncertaintyM:T}}const c=e.length*.2,l=new Set;for(const[p,E]of o)E>=c&&l.add(p);const g=Ho(e.length,l.size,(r==null?void 0:r.uncertaintyM)??1/0,a,n),h=wo(e.length,g,l.size,r,a,n),d=h.tier==="confirmed"||h.tier==="likely";return{prefix:t,observations:e,observationCount:e.length,estimatedLocation:r,confidence:g,commonNeighbors:l,firstSeen:i,lastSeen:a,isLikelyReal:d,classification:h}}function Ho(t,e,n,o,s){const i=Math.min(.4,t/po*.4),a=Math.min(.3,e/4*.3),r=n<1/0?Math.max(0,.2*(1-n/(Me*1e3))):0,c=s-o*1e3,l=c<It?.1*(1-c/It):0;return i+a+r+l}function wo(t,e,n,o,s,i){const a=t>=Eo,r=t>=_o,c=e>=Mo,l=e>=vo,g=n>=go,h=o!==void 0,d=h&&o.uncertaintyM<Me*1e3,E=i-s*1e3<It,S={hasHighObservations:a,hasVeryHighObservations:r,hasGoodConfidence:c,hasHighConfidence:l,hasCommonNeighbors:g,hasLocation:h,hasGoodLocation:d,isRecent:E};if(r&&l)return{tier:"confirmed",reason:`${t} observations at ${(e*100).toFixed(0)}% confidence`,criteria:S};if(a&&l&&g&&d)return{tier:"confirmed",reason:"Strong multi-factor evidence with verified location",criteria:S};if(a&&c&&g)return{tier:"likely",reason:h?`${t} observations with ${n} common neighbors`:`${t} observations, ${n} neighbors (no location)`,criteria:S};if(t>=$t&&c&&d)return{tier:"likely",reason:`Consistent location (±${(o.uncertaintyM/1e3).toFixed(1)}km)`,criteria:S};if(r&&c)return{tier:"likely",reason:`${t} observations suggests real node`,criteria:S};if(t>=$t&&(c||g||h)){const v=[];return g||v.push("few neighbors"),h||v.push("no location"),c||v.push("low confidence"),E||v.push("stale"),{tier:"possible",reason:v.length>0?`Needs: ${v.join(", ")}`:"Moderate evidence",criteria:S}}return{tier:"noise",reason:t<$t?`Only ${t} observations`:"Insufficient corroborating evidence",criteria:S}}function No(t,e){return`${e}:${t.join(">")}`}function Po(t,e){return`${t}→${e}`}function ve(t){const e=t.route??t.route_type;return le(e)?"flood":de(e)?"direct":"unknown"}function Io(t,e){const n=new Map,o=new Map;let s=0;for(const r of t){if(!r.src_hash)continue;const c=r.original_path??r.forwarded_path;if(!c||!Array.isArray(c)||c.length===0)continue;const l=c.map(S=>typeof S=="string"?S.toUpperCase().slice(0,2):String(S).toUpperCase().slice(0,2)),g=e||"unknown",h=r.src_hash,d=No(l,h);let p=n.get(d);p||(p={id:d,hops:l,srcHash:h,dstHash:g,observationCount:0,firstSeen:r.timestamp,lastSeen:r.timestamp,routeType:ve(r),hopCount:l.length},n.set(d,p)),p.observationCount++,p.lastSeen=Math.max(p.lastSeen,r.timestamp),p.firstSeen=Math.min(p.firstSeen,r.timestamp),s++,ve(r)==="direct"&&p.routeType!=="direct"&&(p.routeType="direct")}const i=Array.from(n.values());for(const r of i){const c=Po(r.srcHash,r.dstHash),l=o.get(c)||[];l.push(r),o.set(c,l)}for(const r of o.values())r.sort((c,l)=>l.observationCount-c.observationCount);const a=new Map;for(const[r,c]of o)c.length>0&&a.set(r,c[0]);return{paths:i,byEndpoints:o,canonicalPaths:a,totalObservations:s,uniquePathCount:i.length}}function Ao(t){return{paths:t.paths,byEndpointsEntries:Array.from(t.byEndpoints.entries()),canonicalPathsEntries:Array.from(t.canonicalPaths.entries()),totalObservations:t.totalObservations,uniquePathCount:t.uniquePathCount}}function Do(t,e,n,o,s,i){const a=new Map,r=n!==void 0&&o!==void 0&&(n!==0||o!==0);for(const[g,h]of Object.entries(e)){let d=null,p=.5;r&&h.latitude&&h.longitude&&(h.latitude!==0||h.longitude!==0)&&(d=vt(n,o,h.latitude,h.longitude),p=rn(d)),h.zero_hop&&(p=Math.max(p,.9)),a.set(g,{hash:g,frequency:0,directForwardCount:0,distanceMeters:d,proximityScore:p,hopPositionCounts:[0,0,0,0,0],avgHopDistance:0,typicalHopPosition:0,hopConsistencyScore:0,frequencyScore:0,combinedScore:0,avgDisambiguationConfidence:0,collisionCount:0,resolutionCount:0})}const c=new Map;for(const g of t){const h=kt(g,s);if(h&&h.effectiveLength>=1){const d=h.effective;for(let p=0;p<d.length;p++){const E=d[p],S=Xt(p,h.effectiveLength);if(i){const v=ft(i,E,{position:S,adjacentPrefixes:[...p>0?[d[p-1]]:[],...p<d.length-1?[d[p+1]]:[]],isLastHop:S===1});if(v.hash){const f=a.get(v.hash);if(f){f.frequency++,f.resolutionCount++;const _=c.get(v.hash)||0;c.set(v.hash,_+v.confidence);const C=i.get(E.toUpperCase());C&&!C.isUnambiguous&&f.collisionCount++;const b=Math.min(S-1,4);f.hopPositionCounts[b]++,S===1&&f.directForwardCount++}}}else for(const[v,f]of a)if(xo(E,v)){f.frequency++;const _=Math.min(S-1,4);f.hopPositionCounts[_]++,S===1&&f.directForwardCount++}}}if((!h||h.effectiveLength===0)&&g.src_hash){const d=a.get(g.src_hash);if(d){d.frequency++,d.directForwardCount++,d.hopPositionCounts[0]++,d.resolutionCount++;const p=c.get(g.src_hash)||0;c.set(g.src_hash,p+1)}}}let l=0;for(const g of a.values())l=Math.max(l,g.frequency);for(const g of a.values()){let h=0,d=0,p=0,E=1;for(let v=0;v<g.hopPositionCounts.length;v++){const f=g.hopPositionCounts[v],_=v+1;h+=f,d+=f*_,f>p&&(p=f,E=_)}g.avgHopDistance=h>0?d/h:0,g.typicalHopPosition=E,h>0&&p>0&&(g.hopConsistencyScore=p/h),g.frequencyScore=l>0?g.frequency/l:0;const S=c.get(g.hash)||0;g.avgDisambiguationConfidence=g.resolutionCount>0?S/g.resolutionCount:0,g.combinedScore=g.proximityScore*.3+g.hopConsistencyScore*.3+g.frequencyScore*.4}return a}function xo(t,e){const n=t.toUpperCase(),o=e.startsWith("0x")?e.slice(2,4).toUpperCase():e.slice(0,2).toUpperCase();return n===o}function Et(t,e){return[t,e].sort().join("-")}function ko(t,e,n=1){if(t.length<3)return{loops:[],loopEdgeKeys:new Set};const o=new Map,s=new Map;for(const l of t)s.set(l.key,l),o.has(l.fromHash)||o.set(l.fromHash,new Set),o.has(l.toHash)||o.set(l.toHash,new Set),o.get(l.fromHash).add(l.toHash),o.get(l.toHash).add(l.fromHash);const i=[],a=new Set,r=new Set;function c(l,g,h){if(l===g)return[l];const d=new Set([l]),p=[{node:l,path:[l]}];for(;p.length>0;){const{node:E,path:S}=p.shift(),v=o.get(E);if(v){for(const f of v)if(Et(E,f)!==h){if(f===g)return[...S,f];d.has(f)||(d.add(f),p.push({node:f,path:[...S,f]}))}}}return null}for(const l of t){const g=c(l.fromHash,l.toHash,l.key);if(g&&g.length>=2){const h=g,d=[l.key];for(let C=0;C<g.length-1;C++){const b=Et(g[C],g[C+1]);d.push(b)}const p=[...h].sort().join(",");if(r.has(p))continue;r.add(p);let E=0,S=1/0;for(const C of d){const b=s.get(C);b&&(E+=b.certainCount,S=Math.min(S,b.certainCount),a.add(C))}const v=d.length>0?E/d.length:0,f=e?h.includes(e):!1,_={id:`loop-${i.length}`,edgeKeys:d,nodes:h,size:d.length,avgCertainCount:v,minCertainCount:S===1/0?0:S,includesLocal:f,strength:n>0?S===1/0?0:S/n:0};i.push(_)}}return i.sort((l,g)=>l.includesLocal!==g.includesLocal?l.includesLocal?-1:1:g.strength-l.strength),{loops:i,loopEdgeKeys:a}}const Lo=.5,Fo=.2;function Go(t){return t<=2?.4:t<=5?.6:t<=8?.8:t<=12?1:1.2}function Uo(t){return t<=5?0:t<=10?.2:.4}const be=.6;function $o(t){return t>=be?1:t<=0?0:t/be}function Te(t,e,n){return e+(t-e)*n}function Ko(t,e,n,o,s,i){const a=new Map;if(t.length===0||n.length===0)return a;const r=f=>{const _=Math.round(f/.2)*.2;return Math.max(0,Math.min(2,_))},c=f=>Math.floor(5*f),l=new Set;for(const f of t)l.add(f.fromHash),l.add(f.toHash);const g=n.map(f=>f.timestamp).filter(f=>f!==void 0&&f>0).sort((f,_)=>f-_),h=g.length>=2?(g[g.length-1]-g[0])/60:1,d=new Map;for(const f of t)d.has(f.fromHash)||d.set(f.fromHash,[]),d.has(f.toHash)||d.set(f.toHash,[]),d.get(f.fromHash).push(f),d.get(f.toHash).push(f);const p=new Map;for(const f of l){const _=d.get(f)||[];if(_.length===0)continue;const C=f.startsWith("0x")?f.slice(2,4).toUpperCase():f.slice(0,2).toUpperCase(),b=new Set;let L=0,M=0,T=0,O=0;for(const N of _){const y=N.fromHash===f?N.toHash:N.fromHash;b.add(y),L+=N.packetCount,M+=N.certainCount,T+=N.symmetryRatio,O+=N.floodCount}const I=b.size,F=_.length>0?T/_.length:0,x=_.length>0?M/_.length:0,G=o.paths.filter(N=>N.hops.some(y=>y.toUpperCase()===C)).length;p.set(f,{neighborCount:I,totalEdgePackets:L,avgEdgeCertainCount:x,avgSymmetry:F,floodForwardRatio:L>0?O/L:0,trafficRate:h>0?L/h:0,pathCount:G})}const E=new Map;for(const f of l){const _=p.get(f);if(!_||_.totalEdgePackets<100)continue;const C=Go(_.neighborCount),b=Uo(_.neighborCount),L=$o(_.avgSymmetry),M=Te(C,Lo,L),T=Te(b,Fo,L),O=r(Math.min(M,2)),I=r(Math.min(T,1));let F;_.neighborCount>=6&&_.pathCount>=5?F="backbone":_.neighborCount>=4?F="hub":_.neighborCount>=2?F="relay":F="edge";const x=Math.min(_.avgEdgeCertainCount/10,1),G=Math.min(n.length/1e3,1),N=_.avgSymmetry,y=x*.3+G*.3+N*.4;let k;n.length<100?k="insufficient":n.length<500?k="low":n.length<1e3?k="medium":k="high",E.set(f,{floodFactor:O,directFactor:I,networkRole:F,damping:L,avgSymmetry:_.avgSymmetry,trafficRate:_.trafficRate,floodForwardRatio:_.floodForwardRatio,pathCount:_.pathCount,confidence:y,dataConfidence:k})}const S=new Map;for(const[f,_]of E){const C=c(_.floodFactor);S.has(C)||S.set(C,[]),S.get(C).push(f)}const v=new Map;for(const[,f]of S){if(f.length<=1){f.length===1&&v.set(f[0],E.get(f[0]).floodFactor);continue}const _=[...f].sort((C,b)=>{const L=p.get(C),M=p.get(b);return((L==null?void 0:L.neighborCount)??0)-((M==null?void 0:M.neighborCount)??0)});for(let C=0;C<_.length;C++){const b=_[C],L=E.get(b),M=C%3*.2;v.set(b,r(L.floodFactor+M))}}for(const f of l){const _=p.get(f);if(!_||_.totalEdgePackets<100){a.set(f,{floodFactor:0,directFactor:0,floodSlots:0,directSlots:0,floodDelaySec:0,directDelaySec:0,txDelayFactor:0,directTxDelayFactor:0,trafficIntensity:0,directNeighborCount:(_==null?void 0:_.neighborCount)??0,collisionRisk:0,confidence:0,insufficientData:!0,networkRole:"edge",rationale:"Insufficient data (<100 packets observed)",adjustment:"stable",avgPathPosition:0,pathPositionVariance:0,floodParticipationRate:0,pathDiversity:0,positionDelayMs:0,observationSymmetry:(_==null?void 0:_.avgSymmetry)??0,dataConfidence:"insufficient"});continue}const C=E.get(f),b=v.get(f)??C.floodFactor,L=C.directFactor,M=c(b),T=c(L),O=_.neighborCount;let I=`${O} edge${O!==1?"s":""} observed`;C.avgSymmetry>=.5?I+=`, ${Math.round(C.avgSymmetry*100)}% symmetric`:C.avgSymmetry<.3?I+=`. ⚠️ Low symmetry (${Math.round(C.avgSymmetry*100)}%) — dampened toward default`:I+=`, ${Math.round(C.avgSymmetry*100)}% symmetric — partial damping`,C.dataConfidence==="low"&&(I+=". Limited data");const F=c(.5);let x;M>F?x="increase":M<F?x="decrease":x="stable";const G=f.startsWith("0x")?f.slice(2,4).toUpperCase():f.slice(0,2).toUpperCase(),y=o.paths.filter($=>$.hops.some(Y=>Y.toUpperCase()===G)).flatMap($=>{const Y=$.hops.findIndex(it=>it.toUpperCase()===G);return Y>=0?[Y+1]:[]}),k=y.length>0?y.reduce(($,Y)=>$+Y,0)/y.length:0;let H=0;y.length>1&&(H=y.reduce(($,Y)=>$+Math.pow(Y-k,2),0)/y.length),a.set(f,{floodFactor:b,directFactor:L,floodSlots:M,directSlots:T,floodDelaySec:b,directDelaySec:L,txDelayFactor:b,directTxDelayFactor:L,trafficIntensity:Math.round(C.trafficRate*10)/10,directNeighborCount:_.neighborCount,collisionRisk:0,confidence:C.confidence,insufficientData:!1,networkRole:C.networkRole,rationale:I,adjustment:x,avgPathPosition:Math.round(k*10)/10,pathPositionVariance:Math.round(H*100)/100,floodParticipationRate:Math.round(C.floodForwardRatio*100)/100,pathDiversity:C.pathCount,positionDelayMs:0,observationSymmetry:Math.round(C.avgSymmetry*100)/100,dataConfidence:C.dataConfidence})}return a}function Bo(t,e){const n=new Map,o=new Map(e.map(i=>[i.key,i]));for(const i of e)n.set(i.key,0);if(t.paths.length===0)return n;for(const i of t.paths)for(let a=0;a<i.hops.length-1;a++){const r=i.hops[a],c=i.hops[a+1];for(const l of e){const g=ct(l.fromHash),h=ct(l.toHash);if(g===r&&h===c||g===c&&h===r){const p=n.get(l.key)||0;n.set(l.key,p+i.observationCount);break}}}const s=Math.max(...n.values(),1);for(const[i,a]of n)n.set(i,a/s);for(const[i,a]of n){const r=o.get(i);if(r){const c=.5+.5*r.symmetryRatio;n.set(i,a*c)}}return n}function Yo(t,e=3,n=.3){return[...t.entries()].filter(([,s])=>s>=n).sort((s,i)=>i[1]-s[1]).slice(0,e).map(([s])=>s)}function Vo(t,e){const n=new Map,o=[];if(t.paths.length===0)return{nodeMobility:n,mobileNodes:o};const s=3600*1e3,i=t.paths.map(g=>g.lastSeen).sort((g,h)=>g-h),a=i[0],r=i[i.length-1],c=Math.ceil((r-a)/s)||1,l=new Map;for(const g of t.paths){const h=Math.floor((g.lastSeen-a)/s);for(const d of g.hops){let p=d;for(const[S]of Object.entries(e))if((S.startsWith("0x")?S.slice(2,4).toUpperCase():S.slice(0,2).toUpperCase())===d.toUpperCase()){p=S;break}let E=l.get(p);E||(E={paths:new Set,firstSeen:g.firstSeen,lastSeen:g.lastSeen,windowPresence:new Set},l.set(p,E)),E.paths.add(g.id),E.firstSeen=Math.min(E.firstSeen,g.firstSeen),E.lastSeen=Math.max(E.lastSeen,g.lastSeen),E.windowPresence.add(h)}}for(const[g,h]of l){const d=h.paths.size,p=h.lastSeen-h.firstSeen,E=p>0?p/(1e3*60*60):0,S=c>0?h.windowPresence.size/c:1,v=1-S,f=Math.min(d/10,1),_=v*(1-f*.5),C=_>.3,b={hash:g,pathVolatility:_,pathDiversity:d,avgPathLifespanHours:E,isMobile:C,lastSeen:h.lastSeen,activeWindowRatio:S};n.set(g,b),C&&o.push(g)}return o.sort((g,h)=>{var E,S;const d=((E=n.get(g))==null?void 0:E.pathVolatility)??0;return(((S=n.get(h))==null?void 0:S.pathVolatility)??0)-d}),{nodeMobility:n,mobileNodes:o}}function jo(t,e,n,o=20){const s=[];if(t.paths.length===0)return s;const i=new Map;for(const h of e){const d=ct(h.fromHash),p=ct(h.toHash);i.set(`${d}>${p}`,h),i.set(`${p}>${d}`,h)}const a=new Set;for(const h of n)a.add(ct(h));const r=new Map;for(const h of t.paths){if(h.hops.length===0)continue;const d=h.hops[h.hops.length-1],p=r.get(d)||[];p.push(h.id),r.set(d,p)}const c=[...t.paths].sort((h,d)=>d.observationCount-h.observationCount),l=Date.now(),g=3600*1e3;for(const h of c.slice(0,o)){if(h.hops.length<2)continue;let d=0,p=1/0,E=null,S=0,v=!1;for(let H=0;H<h.hops.length-1;H++){const $=h.hops[H],Y=h.hops[H+1],it=`${$}>${Y}`,at=i.get(it);if(at){const m=at.packetCount>0?at.certainCount/at.packetCount:0;d+=m,S++,m<p&&(p=m,E=at.key)}else d+=.1,S++,.1<p&&(p=.1,E=Et($,Y));(a.has($)||a.has(Y))&&(v=!0)}const f=S>0?d/S:0,_=p===1/0?0:p,C=(l-h.lastSeen)/g,b=Math.exp(-C/24),L=h.observationCount>10&&C<12?.5+(1-C/12)*.5:C>48?-.5:0,M=h.hops[h.hops.length-1],T=r.get(M)||[],O=Math.max(0,T.length-1),I=h.routeType==="direct"?20:30,F=h.hops.length*I,x=f*.4,G=b*.3,N=(L+1)/2*.15,y=Math.min(O/3,1)*.15,k=Math.round((x+G+N+y)*100)/100;s.push({pathKey:h.id,hops:[...h.hops],healthScore:k,weakestLinkKey:E,weakestLinkConfidence:Math.round(_*100)/100,weakestLinkTraceSnr:null,avgEdgeCertainty:Math.round(f*100)/100,observationTrend:Math.round(L*100)/100,alternatePathsCount:O,estimatedLatencyMs:F,observationCount:h.observationCount,routeType:h.routeType==="unknown"?"mixed":h.routeType,lastSeen:h.lastSeen,involvesHub:v})}return s.sort((h,d)=>d.healthScore-h.healthScore),s}const Wo=1e-8,qo=100,Re=3,Xo=4,te=5,zo=20,Qo=.001,Oe=.3,Zo=30,Jo=.05,ts=.7,He=.3;function Kt(t,e){let n=0;for(let o=0;o<t.length;o++)n+=t[o]*e[o];return n}function es(t){return Math.sqrt(Kt(t,t))}function we(t){const e=es(t);if(e>0)for(let n=0;n<t.length;n++)t[n]/=e}function Ne(t,e){const n=Kt(t,e);for(let o=0;o<t.length;o++)t[o]-=n*e[o]}function ns(t,e){const n=t.length,o=new Array(n).fill(0);for(let s=0;s<n;s++)for(let i=0;i<n;i++)o[s]+=t[s][i]*e[i];return o}function os(t){const e=Math.exp(-t/Zo);return Math.max(Jo,e)}function ss(t,e,n,o){const s=e.length,i=new Map(e.map((r,c)=>[r,c])),a=Array(s).fill(null).map(()=>Array(s).fill(0));for(const r of t){const c=i.get(r.fromHash),l=i.get(r.toHash);if(c!==void 0&&l!==void 0&&c!==l){const g=r.strength*r.certainCount;let h=1;if(n){const v=n.get(r.fromHash),f=n.get(r.toHash);if(v&&f){const C=vt(v[0],v[1],f[0],f[1])/1e3;h=os(C)}}let d=1;if(o){const v=[r.fromHash,r.toHash].sort().join("-");d=1-(o.get(v)??0)*ts}const p=r.symmetryRatio??0,E=He+(1-He)*p,S=Math.pow(g,1-Oe)*Math.pow(h,Oe)*d*E;a[c][l]=S,a[l][c]=S}}return a}function is(t){const e=t.length,n=Array(e).fill(null).map(()=>Array(e).fill(0));for(let o=0;o<e;o++){let s=0;for(let i=0;i<e;i++)s+=t[o][i],n[o][i]=-t[o][i];n[o][o]=s}return n}function rs(t){const e=t.length,n=Array(e).fill(1/Math.sqrt(e));let o=0;for(let c=0;c<e;c++){let l=0;for(let g=0;g<e;g++)l+=Math.abs(t[c][g]);o=Math.max(o,l)}const s=Array(e).fill(null).map(()=>Array(e).fill(0));for(let c=0;c<e;c++){for(let l=0;l<e;l++)s[c][l]=-t[c][l];s[c][c]=o+s[c][c]}let i=Array(e).fill(0).map((c,l)=>Math.sin(l*12.9898)*43758.5453%1-.5);Ne(i,n),we(i);let a=0;for(let c=0;c<qo;c++){const l=ns(s,i);Ne(l,n);const g=Kt(l,l)/Kt(i,l);if(we(l),i=l,Math.abs(g-a)<Wo){const h=o-g;return{vector:i,eigenvalue:h}}a=g}const r=o-a;return{vector:i,eigenvalue:r}}function cs(t,e){if(t.length<2)return 0;const n=[];for(const a of t){const r=e.get(a);r&&n.push(r)}if(n.length<2)return 0;const o=Math.min(n.length,20),s=n.length<=o?n:as(n,o);let i=0;for(let a=0;a<s.length;a++)for(let r=a+1;r<s.length;r++){const c=vt(s[a][0],s[a][1],s[r][0],s[r][1])/1e3;i=Math.max(i,c)}return i}function as(t,e){if(e>=t.length)return t;const n=[],o=t.length/e;for(let s=0;s<e;s++)n.push(t[Math.floor(s*o)]);return n}function us(t,e,n,o){const s=e.length;if(s<Re)return null;const i=new Set(e),a=t.filter(p=>i.has(p.fromHash)&&i.has(p.toHash));if(a.length===0)return null;const r=ss(a,e,n,o),c=is(r),{vector:l,eigenvalue:g}=rs(c);if(g<Qo)return null;const h=[],d=[];for(let p=0;p<s;p++)l[p]<0?h.push(e[p]):d.push(e[p]);return h.length<te||d.length<te?null:{group0:h,group1:d,fiedlerValue:g}}function fs(t,e,n,o){const s=e.length;if(s<Re)return{communities:new Map([[0,e]]),nodePartitions:e.map(h=>({hash:h,community:0,fiedlerValue:0})),numCommunities:1,fiedlerValue:0,isConnected:s<=1};const i=[];let a=1/0;const r=[[e,0]];for(;r.length>0;){const[h,d]=r.shift();if((n?cs(h,n):0)>zo&&d<Xo&&h.length>=te*2){const S=us(t,h,n,o);if(S){a=Math.min(a,S.fiedlerValue),r.push([S.group0,d+1]),r.push([S.group1,d+1]);continue}}i.push(h)}const c=new Map,l=[],g=new Map;for(let h=0;h<i.length;h++){c.set(h,i[h]);for(const d of i[h])g.set(d,h)}for(const h of e)l.push({hash:h,community:g.get(h)??0,fiedlerValue:0});return{communities:c,nodePartitions:l,numCommunities:i.length,fiedlerValue:a===1/0?0:a,isConnected:!0}}const ls=3600,ds=86400,hs=604800;function ps(t,e){if(t<=0)return"inactive";const n=e-t;return n<ls?"active":n<ds?"recent":n<hs?"stale":"inactive"}function gs(t,e){if(t<=0)return 0;const n=(e-t)/3600;return n<0?1:Math.exp(-n/12)}function ms(t,e,n){const o=new Set;for(const c of t)o.add(c.fromHash),o.add(c.toHash);const s=Array.from(o);if(s.length<3){const c=new Map;for(const l of s)c.set(l,0);return{communities:c,count:1}}const i=new Map;for(const[c,l]of Object.entries(e))cn(l.latitude,l.longitude)&&i.set(c,[l.latitude,l.longitude]);const a=fs(t,s,i.size>0?i:void 0,n),r=new Map;for(const c of a.nodePartitions)r.set(c.hash,c.community);return{communities:r,count:a.numCommunities}}function Cs(t,e,n,o,s,i,a,r){return t===e?"local":n.includes(t)?"hub":o.includes(t)?"gateway":s.has(t)?"backbone":i.has(t)?"neighbor":a.includes(t)?"mobile":r.has(t)?"ghost":"standard"}function ys(t,e){const n=new Set;for(const o of t){const s=e.get(o);s&&(n.add(s.fromHash),n.add(s.toHash))}return n}function Ss(t,e){const n=new Set;for(const o of t){const s=e.get(o);s&&(n.add(s.fromHash),n.add(s.toHash))}return n}function Es(t,e,n,o,s,i,a,r,c,l,g,h,d,p,E,S){var N;const v=Math.floor(Date.now()/1e3),{communities:f,count:_}=ms(t,h,S),C=ys(i,e),b=Ss(a,e),L=new Set;for(const y of g)y.isLikelyReal&&L.add(y.prefix);const M=new Set,T=new Map,O=new Map,I=new Map;for(const y of t){O.set(y.fromHash,(O.get(y.fromHash)??0)+1),T.set(y.toHash,(T.get(y.toHash)??0)+1);const k=I.get(y.fromHash)??0,H=I.get(y.toHash)??0;I.set(y.fromHash,k+y.packetCount),I.set(y.toHash,H+y.packetCount)}const F=new Set;for(const y of t)F.add(y.fromHash),F.add(y.toHash);d&&F.add(d);const x=new Map;for(const y of l.paths){const k=new Set;for(const H of y.hops)k.add(H);for(const H of k)x.set(H,(x.get(H)??0)+1)}const G=new Map;for(const y of F){const k=ct(y),H=h[y],$=c.get(y),Y=(p==null?void 0:p.has(y))??!1,it=E==null?void 0:E.get(k),at=(it==null?void 0:it.confidence)??1,m=it?!it.isUnambiguous:!1,w=((N=it==null?void 0:it.candidates)==null?void 0:N.length)??1,j=T.get(y)??0,X=O.get(y)??0,z=j+X,Z=(H==null?void 0:H.last_seen)??($==null?void 0:$.lastSeen)??0,et=x.get(k)??0,nt=Cs(y,d,o,s,C,p??new Set,r,M),J={hash:y,prefix:k,name:(H==null?void 0:H.name)??(H==null?void 0:H.node_name)??null,nodeClass:nt,communityId:f.get(y)??0,degree:z,inDegree:j,outDegree:X,betweenness:n.get(y)??0,pathDiversity:et,packetCount:I.get(y)??0,lastSeen:Z,activityLevel:ps(Z,v),recencyScore:gs(Z,v),avgRssi:(H==null?void 0:H.rssi)??null,avgSnr:(H==null?void 0:H.snr)??null,isZeroHop:Y,prefixConfidence:at,hasCollision:m,collisionCandidates:w,traceSnrAggregate:null,traceEdgeCoverage:0,traceReliability:"unknown",isLocal:y===d,isHub:o.includes(y),isGateway:s.includes(y),isBackbone:C.has(y),isMobile:r.includes(y),isGhost:M.has(y),isInLoop:b.has(y),latitude:(H==null?void 0:H.latitude)??null,longitude:(H==null?void 0:H.longitude)??null,contactType:(H==null?void 0:H.contact_type)??null};G.set(y,J)}return{nodeMetrics:G,communityCount:_,backboneNodes:Array.from(C)}}const _s=9;function Ms(t){const e=t.replace(/^0x/i,"").replace(/\s/g,"");if(e.length%2!==0)throw new Error("Invalid hex string: odd number of characters");const n=new Uint8Array(e.length/2);for(let o=0;o<n.length;o++){const s=parseInt(e.substr(o*2,2),16);if(isNaN(s))throw new Error(`Invalid hex character at position ${o*2}`);n[o]=s}return n}function vs(t,e=!0){const n=(t&255).toString(16).padStart(2,"0");return e?n.toUpperCase():n}function Pe(t,e){return(t[e]|t[e+1]<<8|t[e+2]<<16|t[e+3]<<24)>>>0}function bs(t){if(t.length<9)return{type:"trace",traceTag:"00000000",traceTagValue:0,authCode:0,flags:0,pathHashes:[],pathString:"",snrValues:[],isComplete:!1,path:[],targetHash:""};const e=Pe(t,0),n=e.toString(16).toUpperCase().padStart(8,"0"),o=Pe(t,4),s=t[8],i=t.slice(9),a=Array.from(i).map(c=>vs(c,!0)),r=a.join("->");return{type:"trace",traceTag:n,traceTagValue:e,authCode:o,flags:s,pathHashes:a,pathString:r,snrValues:[],isComplete:!1,path:a,targetHash:a.length>0?a[0]:""}}function Ts(t,e){const n=bs(t);if(!n)return null;const o=[],s=e instanceof Uint8Array?Array.from(e):e;for(let a=0;a<s.length;a++){let r=s[a];r>127&&(r-=256);const c=r/4;o.push(Math.max(-20,Math.min(15,c)))}const i=o.length>=n.pathHashes.length;return{...n,snrValues:o,isComplete:i}}function Rs(t,e){if(e!==_s||!t||t.length<6)return null;const n=parseInt(t.slice(0,2),16);if(isNaN(n))return null;const o=n&3;let s=2;if((o===0||o===3)&&(s+=8),s+2>t.length)return null;const i=parseInt(t.slice(s,s+2),16);if(isNaN(i)||i===0)return null;s+=2;const a=s+i*2;if(a>t.length)return null;const r=[];for(let c=s;c<a;c+=2){const l=parseInt(t.slice(c,c+2),16);if(isNaN(l))return null;r.push(l)}return r}const Ie={5:-2.5,6:-5,7:-7.5,8:-10,9:-12.5,10:-15,11:-17.5,12:-20},Ae=7;function Os(t){const e=Math.max(5,Math.min(12,Math.round(t)));return Ie[e]??Ie[Ae]}const Bt={EXCELLENT:6,GOOD:3,FAIR:0};function Yt(t,e){const o=Os(e??Ae),s=t-o;return s>=Bt.EXCELLENT?"excellent":s>=Bt.GOOD?"good":s>=Bt.FAIR?"fair":s>=Bt.FAIR-3?"poor":"critical"}function Hs(t){if(t._traceSnrPath!=null&&t._traceSnrPath.length>0)return t._traceSnrPath;if(t.raw_packet){const e=t.payload_type??t.type,n=Rs(t.raw_packet,e);if(n&&n.length>0)return n}return[]}function ws(t){const e=t.length;if(e===0)return{mean:0,median:0,min:0,max:0,stdDev:0,count:0};const o=t.reduce((g,h)=>g+h,0)/e,s=Math.min(...t),i=Math.max(...t),a=t.reduce((g,h)=>g+(h-o)**2,0)/e,r=Math.sqrt(a),c=[...t].sort((g,h)=>g-h),l=e%2===1?c[Math.floor(e/2)]:(c[e/2-1]+c[e/2])/2;return{mean:o,median:l,min:s,max:i,stdDev:r,count:e}}function Ns(t,e){const n=t.count+e.count;if(n===0)return{mean:0,median:0,min:0,max:0,stdDev:0,count:0};const o=(t.mean*t.count+e.mean*e.count)/n,s=(t.median*t.count+e.median*e.count)/n,i=Math.min(t.min,e.min),a=Math.max(t.max,e.max),r=t.stdDev**2,c=e.stdDev**2,l=(t.count*(r+(t.mean-o)**2)+e.count*(c+(e.mean-o)**2))/n;return{mean:o,median:s,min:i,max:a,stdDev:Math.sqrt(l),count:n}}function ee(t,e){return`${t}>${e}`}function De(t){if(!t.payload){const e=t._traceTag,n=t._tracePathHashes,o=t._traceSnrPath;if(!e||!n||n.length===0||!o||o.length===0)return null;const s=[];for(const i of o){let a=i;a>127&&(a-=256);const r=a/4;s.push(Math.max(-20,Math.min(15,r)))}return{traceTag:e,pathHashes:n,snrValues:s,timestamp:t.timestamp??0,srcHash:t.src_hash}}try{const e=Ms(t.payload),n=Hs(t),o=Ts(e,n);return!o||o.pathHashes.length===0||o.snrValues.length===0?null:{traceTag:o.traceTag,pathHashes:o.pathHashes,snrValues:o.snrValues,timestamp:t.timestamp??0,srcHash:t.src_hash}}catch{return null}}function ne(t,e,n,o,s,i,a,r){const c=t.toUpperCase();if(r){const l=r.get(c);if(l&&l.observationCount>=3&&l.confidence>=.7)return{hash:l.hash,confidence:l.confidence}}if(a){const l=a.confirmedResolutions.get(c);if(l&&l.observationCount>=3&&l.confidence>=.7)return{hash:l.hash,confidence:l.confidence}}if(e){const l=s==null?void 0:s.get(c);if(l)return{hash:l,confidence:.8};if(i){const g=ft(i,c,{position:n,adjacentPrefixes:o});if(g.hash)return{hash:g.hash,confidence:g.confidence}}}else{if(i){const g=ft(i,c,{position:n,adjacentPrefixes:o});if(g.hash)return{hash:g.hash,confidence:g.confidence}}const l=s==null?void 0:s.get(c);if(l)return{hash:l,confidence:.6}}return{hash:`~${c}`,confidence:0}}function Ps(t,e){const n=e instanceof Map?{prefixToHash:e}:e??{},{prefixToHash:o,prefixLookup:s,srcHashResolver:i,windowHours:a,previousTraceEvidence:r,localHash:c}=n;let l=o;if(!l&&s){l=new Map;for(const[M,T]of s)T.bestMatch&&l.set(M,T.bestMatch)}const g=!!(s||i),h=[],d=[];let p=0;for(const M of t){if((M.type??M.payload_type)!==sn.TRACE)continue;d.push(M);const O=M.timestamp??0;O>p&&(p=O);const I=De(M);I&&h.push(I)}let E=h;if(a!=null&&a>0&&p>0){const M=p-a*3600;E=h.filter(T=>T.timestamp>=M)}const S={confirmedResolutions:new Map,confirmedLinks:[]};if(E.length===0)return{traceLinks:new Map,feedback:S};const v=new Map;for(const M of E){const T=v.get(M.traceTag);(!T||M.snrValues.length>T.snrValues.length)&&v.set(M.traceTag,M)}const f=new Map,_=new Map,C=[...v.values()].sort((M,T)=>M.timestamp-T.timestamp);for(const M of C){const{pathHashes:T,snrValues:O,traceTag:I,timestamp:F,srcHash:x}=M,G=[];for(let y=0;y<T.length;y++){const k=T[y].toUpperCase(),H=y===0&&!!x,$=[];if(y>0&&$.push(T[y-1].toUpperCase()),y<T.length-1&&$.push(T[y+1].toUpperCase()),g){const Y=ne(k,H,T.length-y,$,i,s,r,_);G.push({prefix:k,...Y})}else{const Y=(l==null?void 0:l.get(k))??`~${k}`;G.push({prefix:k,hash:Y,confidence:Y.startsWith("~")?0:.5})}}let N=null;if(x){const y=x.replace(/^0x/i,"").slice(0,2).toUpperCase();if(g){const k=T.length>0?[T[0].toUpperCase()]:[],H=ne(y,!0,T.length+1,k,i,s,r,_);N={prefix:y,...H}}else if(x.replace(/^0x/i,"").length>=8)N={prefix:y,hash:x,confidence:1};else{const H=(l==null?void 0:l.get(y))??`~${y}`;N={prefix:y,hash:H,confidence:H.startsWith("~")?0:.5}}}for(let y=0;y<O.length&&y<G.length;y++){const k=G[y];let H;if(y===0){if(!N)continue;H=N}else H=G[y-1];if(H.prefix===k.prefix)continue;const $=`${H.hash}>${k.hash}`;let Y=f.get($);Y||(Y={fromPrefix:H.prefix,toPrefix:k.prefix,fromHash:H.hash,toHash:k.hash,snrValues:[],timestamps:[],traceTags:new Set,lastSeen:0},f.set($,Y)),Y.snrValues.push(O[y]),Y.timestamps.push(F),Y.traceTags.add(I),Y.lastSeen=Math.max(Y.lastSeen,F)}N&&N.confidence>=.7&&!N.hash.startsWith("~")&&xe(_,N.prefix,N.hash,N.confidence,O[0]??0);for(let y=0;y<G.length;y++){const k=G[y];if(k.confidence>=.7&&!k.hash.startsWith("~")){const H=y<O.length?O[y]:0;xe(_,k.prefix,k.hash,k.confidence,H)}}}if(c){const M=ct(c);let T=d;if(a!=null&&a>0&&p>0){const O=p-a*3600;T=d.filter(I=>(I.timestamp??0)>=O)}for(const O of T){if(O.packet_origin==="tx_local"||O.snr==null)continue;const I=De(O);if(I&&(I.pathHashes.some(H=>H.toUpperCase()===M)||I.srcHash&&ct(I.srcHash)===M))continue;const F=kt(O,c);if(!F||F.effectiveLength===0)continue;const x=F.effective[F.effectiveLength-1];if(!x)continue;const G=ne(x,!1,1,[M],i,s,r,_);if(G.hash===c||x===M)continue;const N=`${G.hash}>${c}`;let y=f.get(N);y||(y={fromPrefix:x,toPrefix:M,fromHash:G.hash,toHash:c,snrValues:[],timestamps:[],traceTags:new Set,lastSeen:0},f.set(N,y)),y.snrValues.push(O.snr),y.timestamps.push(O.timestamp??0),I&&y.traceTags.add(I.traceTag),y.lastSeen=Math.max(y.lastSeen,O.timestamp??0)}}const b=new Map;for(const[M,T]of f){if(T.snrValues.length===0)continue;const O=ws(T.snrValues),I=T.fromHash.startsWith("~"),F=T.toHash.startsWith("~"),x=!I&&!F?Et(T.fromHash,T.toHash):null,G=Is(T.snrValues,T.timestamps,T.lastSeen),N=As(T.snrValues),y=`${T.toHash}>${T.fromHash}`,k=f.has(y),H=T.lastSeen>0?Math.exp(-(p-T.lastSeen)/(12*3600)):.5,$=Math.min(1,O.count/10)*H*(k?1:.7);b.set(M,{fromPrefix:T.fromPrefix,toPrefix:T.toPrefix,fromHash:T.fromHash,toHash:T.toHash,directedKey:M,edgeKey:x,snr:O,uniqueTraceCount:T.traceTags.size,quality:Yt(O.mean,n.spreadingFactor),lastSeen:T.lastSeen,confidence:$,recencyWeightedSnr:G,trend:N})}const L=Ds(_,b);return{traceLinks:b,feedback:L}}function xe(t,e,n,o,s){const i=t.get(e);i?i.hash===n?(i.observationCount++,i.avgSnrEvidence=(i.avgSnrEvidence*(i.observationCount-1)+s)/i.observationCount,i.confidence=Math.max(i.confidence,o)):o>i.confidence&&t.set(e,{hash:n,confidence:o,observationCount:1,avgSnrEvidence:s}):t.set(e,{hash:n,confidence:o,observationCount:1,avgSnrEvidence:s})}function Is(t,e,n){if(t.length===0)return 0;if(e.length!==t.length)return t.reduce((a,r)=>a+r,0)/t.length;const o=12*3600;let s=0,i=0;for(let a=0;a<t.length;a++){const r=Math.max(0,n-e[a]),c=Math.exp(-r*Math.LN2/o);s+=t[a]*c,i+=c}return i>0?s/i:t.reduce((a,r)=>a+r,0)/t.length}function As(t){if(t.length<4)return"insufficient";const e=Math.floor(t.length/2),n=t.slice(0,e).reduce((i,a)=>i+a,0)/e,s=t.slice(e).reduce((i,a)=>i+a,0)/(t.length-e)-n;return s>1.5?"improving":s<-1.5?"degrading":"stable"}function Ds(t,e){const n=[];for(const o of e.values())!o.fromHash.startsWith("~")&&!o.toHash.startsWith("~")&&o.confidence>=.5&&n.push({fromHash:o.fromHash,toHash:o.toHash,avgSnr:o.snr.mean,count:o.snr.count});return{confirmedResolutions:new Map(t),confirmedLinks:n}}function xs(t,e,n,o){const s=`${t}>${e}`,i=`${e}>${t}`;let a=n.get(s),r=n.get(i);if(!a&&!r){const p=ct(t),E=ct(e),S=ee(p,E),v=ee(E,p);a=n.get(S),r=n.get(v)}if(!a&&!r)return null;const c=(a==null?void 0:a.snr)??null,l=(r==null?void 0:r.snr)??null;let g=null;c&&l?g=Ns(c,l):g=c??l;const h=c&&l?Math.abs(c.mean-l.mean):null;let d="unknown";return c&&l?d=Yt(Math.min(c.mean,l.mean),o):c?d=Yt(c.mean,o):l&&(d=Yt(l.mean,o)),{forward:c,reverse:l,composite:g,asymmetryDb:h,quality:d}}function ks(t,e=null){const n={improving:0,stable:0,degrading:0,insufficient:0},o={excellent:0,good:0,fair:0,poor:0,critical:0};if(t.size===0)return{totalDirectedLinks:0,totalTraces:0,totalObservations:0,bidirectionalLinks:0,meanSnr:0,medianSnr:0,avgConfidence:0,trendCounts:n,qualityCounts:o,windowHours:e};let s=0,i=0,a=0;const r=[],c={...o},l={...n},g=new Set;for(const f of t.values())s+=f.snr.count,i+=f.snr.mean*f.snr.count,r.push(f.snr.mean),a+=f.confidence,c[f.quality]++,l[f.trend]++,g.add(f.directedKey);let h=0;const d=new Set;for(const f of t.values()){const _=ee(f.toPrefix,f.fromPrefix);g.has(_)&&!d.has(f.directedKey)&&(h++,d.add(f.directedKey),d.add(_))}let p=0;for(const f of t.values())p+=f.uniqueTraceCount;p=Math.ceil(p/2);const E=s>0?i/s:0,S=[...r].sort((f,_)=>f-_),v=S.length%2===1?S[Math.floor(S.length/2)]:S.length>0?(S[S.length/2-1]+S[S.length/2])/2:0;return{totalDirectedLinks:t.size,totalTraces:p,totalObservations:s,bidirectionalLinks:h,meanSnr:E,medianSnr:v,avgConfidence:t.size>0?a/t.size:0,trendCounts:l,qualityCounts:c,windowHours:e}}function Ls(t,e,n,o,s,i={}){const{windowHours:a}=i,r=Ps(t,i),c=r.traceLinks,l=r.feedback;if(c.size>0){const d=i.spreadingFactor;for(const p of e){const E=xs(p.fromHash,p.toHash,c,d);E&&(p.traceQuality=E)}}const g=ks(c,a);Fs(c,o,n),Gs(c,e,s);const h=Us(g,l);return{traceLinks:c,traceLinkSummary:g,traceDisambiguationFeedback:l,tokens:h}}function Fs(t,e,n){var o;if(t.size!==0)for(const s of e){if(!s.weakestLinkKey)continue;const i=n.get(s.weakestLinkKey);(o=i==null?void 0:i.traceQuality)!=null&&o.composite&&(s.weakestLinkTraceSnr=i.traceQuality.composite.mean)}}function Gs(t,e,n){var o,s;if(t.size!==0)for(const[i,a]of n){let r=0,c=0,l=0,g=0;for(const h of e)h.fromHash!==i&&h.toHash!==i||(l++,(o=h.traceQuality)!=null&&o.composite&&(r+=h.traceQuality.composite.mean,c++,g++));if(c>0){const h=[];for(const p of e)p.fromHash!==i&&p.toHash!==i||(s=p.traceQuality)!=null&&s.composite&&h.push(p.traceQuality.composite.mean);if(h.length>0){const p=h.reduce((C,b)=>C+b,0)/h.length,E=Math.min(...h),S=Math.max(...h),v=[...h].sort((C,b)=>C-b),f=v.length%2===1?v[Math.floor(v.length/2)]:(v[v.length/2-1]+v[v.length/2])/2,_=h.reduce((C,b)=>C+(b-p)**2,0)/h.length;a.traceSnrAggregate={mean:p,median:f,min:E,max:S,stdDev:Math.sqrt(_),count:h.length}}a.traceEdgeCoverage=l>0?g/l:0;const d=r/c;a.traceReliability=d>=5?"high":d>=0?"medium":"low"}}}function Us(t,e){return[{fn:"traceLinks.directed",value:String(t.totalDirectedLinks),group:"worker",color:"teal"},{fn:"traceLinks.bidir",value:String(t.bidirectionalLinks),group:"worker",color:"teal"},{fn:"traceSummary.meanSnr",value:`${t.meanSnr.toFixed(1)} dB`,group:"analysis",color:t.meanSnr>=5?"green":t.meanSnr>=0?"amber":"red"},{fn:"traceSummary.medianSnr",value:`${t.medianSnr.toFixed(1)} dB`,group:"analysis",color:"zinc"},{fn:"traceSummary.confidence",value:`${(t.avgConfidence*100).toFixed(0)}%`,group:"analysis",color:"zinc"},{fn:"feedback.confirmed",value:String(e.confirmedResolutions.size),group:"worker",color:"teal"},{fn:"feedback.links",value:String(e.confirmedLinks.length),group:"worker",color:"teal"}]}const $s=336;function Ks(t,e,n,o=.4,s,i,a,r,c,l,g,h,d,p){const E=[...t].sort((u,R)=>(u.timestamp??0)-(R.timestamp??0)),S=new Map;for(const u of E){if(!u.packet_hash)continue;const R=S.get(u.packet_hash);R?R.push(u):S.set(u.packet_hash,[u])}let v=0,f=0,_=0;const C=new Map;for(const[,u]of S){if(u.length<2)continue;v++;const R=new Map,U=new Set;for(const P of u){const A=P.original_path??P.forwarded_path;if(!A||!Array.isArray(A)||A.length===0)continue;const K=A.map(B=>String(B).toUpperCase()).join("-");R.has(K)||(R.set(K,A.map(B=>String(B).toUpperCase())),f++);const tt=String(A[A.length-1]).toUpperCase();U.add(tt)}if(U.size>=2){const P=Array.from(U);for(let A=0;A<P.length;A++)for(let K=A+1;K<P.length;K++){const tt=P[A]<P[K]?`${P[A]}-${P[K]}`:`${P[K]}-${P[A]}`,B=C.get(tt);B?(B.count++,B.confidence=Math.min(.95,B.confidence+.05)):C.set(tt,{count:1,confidence:.6})}}}const b=mn(E,e,n,s,i),L=Do(E,e,s,i,n,b),M=n?ct(n):null,T=new Map;for(const[u,R]of L)T.set(u,R.combinedScore);const O=new Map,I=l??c!==void 0?new Nn:void 0,F=new Map,x=new Map,G=new Map,N=new Map,y=Math.floor(Date.now()/1e3),k=u=>{if(!u||u<=0)return .1;const R=(y-u)/3600;return R<0?1:Math.exp(-R/12)},H=(u,R,U,P,A,K,tt,B,W)=>{const q=Et(u,R),D=O.get(q),[Q,rt]=u<R?[u,R]:[R,u],pt=u===Q,Ct=le(K)||K===void 0,lt=de(K),gt=k(tt);if(D)D.count++,D.confidenceSum+=U,D.recencySum+=gt,D.minHopDistance=Math.min(D.minHopDistance,A),A<D.hopDistanceCounts.length&&D.hopDistanceCounts[A]++,P?D.certainCount++:D.uncertainCount++,W||(pt?D.forwardCount++:D.reverseCount++),Ct?D.floodCount++:lt&&D.directCount++,B!==void 0&&B>0&&(D.viterbiConfidenceSum+=B,D.viterbiObservationCount++);else{const st=[0,0,0,0,0,0,0,0,0,0];A<st.length&&st[A]++,O.set(q,{fromHash:Q,toHash:rt,key:q,count:1,confidenceSum:U,minHopDistance:A,hopDistanceCounts:st,certainCount:P?1:0,uncertainCount:P?0:1,forwardCount:!W&&pt?1:0,reverseCount:!W&&!pt?1:0,floodCount:Ct?1:0,directCount:lt?1:0,recencySum:gt,viterbiConfidenceSum:B??0,viterbiObservationCount:B!==void 0&&B>0?1:0})}},$=fo(b),Y=[];let it=0,at=0,m=0,w=0;const j=new Set,X=new Map;let z=0,Z=0,et=0;for(const u of E){const R=kt(u,n);if(!R)continue;const U=R.effective,P=R.effectiveLength,A=R.original,K=new Set;if(u.src_hash&&A.length>=1){const W=A[0],q=u.src_hash.toUpperCase();if(q!==W){const D=ft(b,q,{position:P+1,adjacentPrefixes:[W]}),Q=ft(b,W,{position:P,adjacentPrefixes:[q,...A.length>1?[A[1]]:[]]});if(D.hash&&Q.hash&&D.hash!==Q.hash){const rt=Object.keys(e).includes(D.hash),pt=D.confidence*Q.confidence,Ct=pt>=.6&&rt,lt=pt*(rt?1:.8),gt=P+1,st=u.route??u.route_type;H(D.hash,Q.hash,lt,Ct,gt,st,u.timestamp,void 0,u.is_duplicate),K.add(D.hash),K.add(Q.hash)}}}const B=(u.type??u.payload_type)===4;if(B&&P===0&&u.src_hash&&n){const W=u.src_hash.toUpperCase(),q=ft(b,W,{position:1,isLastHop:!0});if(q.hash&&q.hash!==n){const D=u.route??u.route_type;H(q.hash,n,1,!0,0,D,u.timestamp,void 0,u.is_duplicate),K.add(q.hash),K.add(n),G.set(q.hash,(G.get(q.hash)||0)+1)}}if(n&&P>=1){const W=P-1,q=U[W];if(B){const Q=N.get(q);Q?(Q.count++,typeof u.rssi=="number"&&!isNaN(u.rssi)&&(Q.rssiSum+=u.rssi,Q.rssiCount++),typeof u.snr=="number"&&!isNaN(u.snr)&&(Q.snrSum+=u.snr,Q.snrCount++),Q.lastSeen=Math.max(Q.lastSeen,u.timestamp??0)):N.set(q,{prefix:q,count:1,rssiSum:typeof u.rssi=="number"&&!isNaN(u.rssi)?u.rssi:0,rssiCount:typeof u.rssi=="number"&&!isNaN(u.rssi)?1:0,snrSum:typeof u.snr=="number"&&!isNaN(u.snr)?u.snr:0,snrCount:typeof u.snr=="number"&&!isNaN(u.snr)?1:0,lastSeen:u.timestamp??0,resolvedHashes:new Map})}const D=ft(b,q,{position:1,adjacentPrefixes:W>0?[U[W-1]]:[],isLastHop:!0});if(B&&D.hash){const Q=N.get(q);if(Q){const rt=Q.resolvedHashes.get(D.hash);rt?(rt.count++,rt.confidenceSum+=D.confidence):Q.resolvedHashes.set(D.hash,{count:1,confidenceSum:D.confidence})}}if(D.hash&&D.hash!==n){const rt=D.confidence,pt=u.route??u.route_type;H(D.hash,n,rt,!0,0,pt,u.timestamp,void 0,u.is_duplicate),K.add(D.hash),K.add(n),G.set(D.hash,(G.get(D.hash)||0)+1)}}if(P>=2){const q={edgeHistory:lo(O),observationOverrideThreshold:.8,enableGhostNodes:!0,minEdgeObservationsForHistory:3,terrainGrid:c,feasibilityCache:I,enableTerrainAware:l??c!==void 0},D=ao($,U,q),Q=u.packet_hash,rt=u.timestamp??0,Ct=(rt>0?(y-rt)/3600:1/0)<=$s,lt=Q&&!j.has(Q);if(lt&&Ct?(j.add(Q),it++,D.hasGhostNodes&&at++,D.usedObservationOverride&&m++,D.totalCost!==1/0&&(w+=D.confidence)):lt&&j.add(Q),D.hasGhostNodes&&Ct){const st=uo(D,rt,u.packet_hash);Y.push(...st)}for(let st=0;st<D.nodes.length-1;st++){const dt=D.nodes[st],ht=D.nodes[st+1];if(!zt(dt)||!zt(ht))continue;const yt=dt.hash,wt=ht.hash;if(yt===wt)continue;const _t=dt.confidence,Mt=ht.confidence,Je=Xt(st+1,P),ai=Je===1,ui=_t>=.6&&Mt>=.6,tn=Mt>=.9,fi=ai&&Mt>=.6,en=ui||tn||fi;K.add(yt),K.add(wt),st>0&&st<D.nodes.length-1&&x.set(yt,(x.get(yt)||0)+1);const nn=tn?Mt:_t*Mt;if(!en&&nn<o)continue;const li=Je,di=u.route??u.route_type;H(yt,wt,nn,en,li,di,u.timestamp,D.confidence,u.is_duplicate)}const gt=D.nodes.filter(zt);if(gt.length>=3)for(let st=0;st<gt.length-2;st++){const dt=gt[st].hash,ht=gt[st+2].hash,yt=gt[st+1].hash;if(dt===ht)continue;const wt=dt<ht?`${dt}-${ht}`:`${ht}-${dt}`,_t=X.get(wt);if(_t)_t.count++,_t.totalConfidence+=D.confidence,_t.intermediates.set(yt,(_t.intermediates.get(yt)||0)+1);else{const Mt=new Map;Mt.set(yt,1),X.set(wt,{endpointA:dt<ht?dt:ht,endpointB:dt<ht?ht:dt,intermediates:Mt,totalConfidence:D.confidence,count:1})}}}else if(P===1){const W=U[0],q=ft(b,W,{position:1,isLastHop:!0});q.hash&&K.add(q.hash)}for(const W of K)F.set(W,(F.get(W)||0)+1)}const nt=8,J=9;for(const u of E){const R=u.type??u.payload_type;if(R!==J&&R!==nt)continue;const U=u.original_path??u.forwarded_path;if(!U||!Array.isArray(U)||U.length<2)continue;const P=U.map(A=>String(A).toUpperCase());R===J?Z++:et++;for(let A=0;A<P.length-1;A++){const K=P[A],tt=P[A+1];if(K===tt)continue;const B=ft(b,K,{position:P.length-A,adjacentPrefixes:A>0?[P[A-1]]:[]}),W=ft(b,tt,{position:P.length-A-1,adjacentPrefixes:[K,...A+2<P.length?[P[A+2]]:[]]});if(!B.hash||!W.hash||B.hash===W.hash)continue;const q=B.confidence*W.confidence,D=B.confidence>=.6&&W.confidence>=.6,Q=B.hash===n,rt=W.hash===n,pt=Object.keys(e).includes(B.hash),Ct=Object.keys(e).includes(W.hash);let lt;Q||rt?lt=0:pt||Ct?lt=1:lt=Math.max(2,Math.min(A+1,5)),H(B.hash,W.hash,q,D,lt,2,u.timestamp,q*.8,u.is_duplicate),z++,F.set(B.hash,(F.get(B.hash)||0)+1),F.set(W.hash,(F.get(W.hash)||0)+1),A>0&&A<P.length-2&&x.set(B.hash,(x.get(B.hash)||0)+1)}}const ot=new Map;let Vt=0;for(const[u,R]of F){const U=x.get(u)||0,P=R>0?U/R:0;ot.set(u,P),Vt=Math.max(Vt,P)}if(Vt>0)for(const[u,R]of ot)ot.set(u,R/Vt);const Fe=new Set,Ge=new Set,Ue=[...G.values()].reduce((u,R)=>u+R,0);for(const[u,R]of G){if(u===n)continue;const U=Ue>0?R/Ue:0;if(U>=.1){Fe.add(u);const P=ot.get(u)||0;ot.set(u,Math.max(P,U))}else if(U>=.07){Ge.add(u);const P=ot.get(u)||0;ot.set(u,Math.max(P,U))}}const jt=Array.from(Fe),$e=Array.from(Ge),Vs=5,js=.5;for(const u of X.values()){if(u.count<Vs||u.totalConfidence/u.count<js)continue;const U=Et(u.endpointA,u.endpointB);if(O.has(U)){const P=O.get(U);P.count+=Math.floor(u.count*.5),P.confidenceSum+=u.totalConfidence*.5,P.viterbiConfidenceSum+=u.totalConfidence,P.viterbiObservationCount+=u.count}else{const P=[0,0,0,0,0,0,0,0,0,0];P[2]=u.count,O.set(U,{fromHash:u.endpointA,toHash:u.endpointB,key:U,count:u.count,confidenceSum:u.totalConfidence*.7,minHopDistance:2,hopDistanceCounts:P,certainCount:0,uncertainCount:u.count,forwardCount:Math.floor(u.count/2),reverseCount:Math.ceil(u.count/2),floodCount:u.count,directCount:0,recencySum:u.count*.5,viterbiConfidenceSum:u.totalConfidence,viterbiObservationCount:u.count})}}const Ws=3,qs=.6;for(const[u,R]of C){if(R.count<Ws||R.confidence<qs)continue;const[U,P]=u.split("-"),A=ft(b,U,{position:1,isLastHop:!0}),K=ft(b,P,{position:1,isLastHop:!0});if(!A.hash||!K.hash||A.hash===K.hash)continue;const tt=Et(A.hash,K.hash),B=O.get(tt),W=R.confidence*Math.min(A.confidence,K.confidence);if(B)B.count+=R.count,B.confidenceSum+=W*R.count,B.recencySum+=R.count*.7,W>=.6?B.certainCount+=Math.floor(R.count*.5):B.uncertainCount+=R.count,_++;else{const q=[0,0,0,0,0,0,0,0,0,0];q[1]=R.count;const[D,Q]=A.hash<K.hash?[A.hash,K.hash]:[K.hash,A.hash];O.set(tt,{fromHash:D,toHash:Q,key:tt,count:R.count,confidenceSum:W*R.count,minHopDistance:1,hopDistanceCounts:q,certainCount:W>=.6?Math.floor(R.count*.3):0,uncertainCount:R.count,forwardCount:Math.floor(R.count/2),reverseCount:Math.ceil(R.count/2),floodCount:R.count,directCount:0,recencySum:R.count*.7,viterbiConfidenceSum:0,viterbiObservationCount:0}),_++}}const ut=[],Ot=[],se=[];let At=0,Wt=0;const ie=new Set(jt),Dt=new Set;for(const u of O.values()){const R=u.confidenceSum/u.count;At=Math.max(At,u.count),Wt=Math.max(Wt,u.certainCount);const U=ie.has(u.fromHash)||ie.has(u.toHash),P=u.certainCount>=5,A=u.forwardCount+u.reverseCount,K=A>0?Math.min(u.forwardCount,u.reverseCount)/Math.max(u.forwardCount,u.reverseCount):0;let tt="balanced";K<.7&&A>0&&(tt=u.forwardCount>u.reverseCount?"forward":"reverse");const W=u.floodCount+u.directCount>0&&u.directCount>u.floodCount,q=u.count>0?u.recencySum/u.count:0,D={fromHash:u.fromHash,toHash:u.toHash,key:u.key,packetCount:u.count,avgConfidence:R,strength:0,avgRecency:q,hopDistanceFromLocal:u.minHopDistance,isHubConnection:U,isCertain:P,certainCount:u.certainCount,forwardCount:u.forwardCount,reverseCount:u.reverseCount,symmetryRatio:K,dominantDirection:tt,floodCount:u.floodCount,directCount:u.directCount,isDirectPathEdge:W};ut.push(D),P&&(Ot.push(D),Dt.add(u.key))}for(const u of ut)!Dt.has(u.key)&&u.packetCount>=2&&se.push(u);if(r&&r.length>0&&n)for(const u of r){if(u.hash===n)continue;const R=Et(n,u.hash),U=ut.find(P=>P.key===R);if(U)U.isZeroHop=!0,U.isCertain=!0,U.avgConfidence=Math.max(U.avgConfidence,.95),u.avgRssi!=null&&(U.avgRssi=u.avgRssi),u.avgSnr!=null&&(U.avgSnr=u.avgSnr),Dt.has(R)||(Ot.push(U),Dt.add(R));else{const[P,A]=n<u.hash?[n,u.hash]:[u.hash,n],K={fromHash:P,toHash:A,key:R,packetCount:u.advertCount,avgConfidence:1,strength:1,avgRecency:1,hopDistanceFromLocal:0,isHubConnection:ie.has(u.hash),isCertain:!0,certainCount:u.advertCount,forwardCount:0,reverseCount:u.advertCount,symmetryRatio:0,dominantDirection:"reverse",floodCount:u.advertCount,directCount:0,isDirectPathEdge:!1,isZeroHop:!0,avgRssi:u.avgRssi,avgSnr:u.avgSnr};if(u.lastSeen&&u.lastSeen>0){const tt=(y-u.lastSeen)/3600;K.avgRecency=tt>=0?Math.exp(-tt/12):1}ut.push(K),Ot.push(K),Dt.add(R)}}for(const u of ut){const R=O.get(u.key),U=R&&R.viterbiObservationCount>0?R.viterbiConfidenceSum/R.viterbiObservationCount:0,P=At>0?u.packetCount/At:0;u.strength=P*.3+u.avgConfidence*.3+U*.25+u.avgRecency*.15}ut.sort((u,R)=>R.certainCount-u.certainCount),Ot.sort((u,R)=>{const U=u.certainCount+(u.isHubConnection?1e3:0);return R.certainCount+(R.isHubConnection?1e3:0)-U}),se.sort((u,R)=>u.packetCount-R.packetCount);const Ke=Ot.slice(0,100),Xs=se.slice(0,100),re=new Map(ut.map(u=>[u.key,u])),{loops:zs,loopEdgeKeys:ce}=ko(Ot,n,Wt);for(const u of ut)u.isLoopEdge=ce.has(u.key);const Ht=Io(E,n),Qs=Ko(ut,F,E,Ht),ae=Bo(Ht,ut),Be=Yo(ae,3,.3),{nodeMobility:Ye,mobileNodes:Ve}=Vo(Ht,e),je=jo(Ht,ut,jt,20),ue=[];for(const u of N.values()){let R=null,U=0,P=0;for(const[A,K]of u.resolvedHashes){if(A===n)continue;const tt=K.count>0?K.confidenceSum/K.count:0,B=K.count*tt;B>U&&(U=B,R=A,P=tt)}R&&ue.push({hash:R,prefix:u.prefix,count:u.count,confidence:P,avgRssi:u.rssiCount>0?u.rssiSum/u.rssiCount:null,avgSnr:u.snrCount>0?u.snrSum/u.snrCount:null,lastSeen:u.lastSeen})}ue.sort((u,R)=>R.count-u.count);let We=0,qt=0;const qe=[],fe=[];let Xe=0;for(const[u,R]of b){if(We+=R.confidence,!R.isUnambiguous){const{isReplacement:U,activeCandidates:P}=Cn(R.candidates);if(!(U&&P.length<=1)){const A=P.length;if(A>1){qt++;const K=P.map(tt=>tt.hash);fe.push({prefix:u,candidateCount:A,candidateHashes:K}),R.confidence<.5&&qe.push(u)}}}for(const U of L.values())if(U.hash.toUpperCase().startsWith(u)||U.hash.slice(2).toUpperCase().startsWith(u)){Xe+=U.resolutionCount;break}}fe.sort((u,R)=>R.candidateCount-u.candidateCount);const Zs=fe.slice(0,5),Js={totalPrefixes:b.size,unambiguousPrefixes:b.size-qt,collisionPrefixes:qt,collisionRate:b.size>0?Math.round(qt/b.size*1e3)/10:0,avgConfidence:b.size>0?Math.round(We/b.size*1e3)/1e3:0,lowConfidencePrefixes:qe,highCollisionPrefixes:Zs,totalResolutions:Xe},ze=Ro(Y,y*1e3),ti=r?new Set(r.map(u=>u.hash)):new Set,{nodeMetrics:Qe,communityCount:ei,backboneNodes:ni}=Es(ut,re,ot,jt,$e,Be,ce,Ve,Ye,Ht,ze,e,n,ti,b,ae),oi=Ls(E,ut,re,je,Qe,{prefixLookup:b,srcHashResolver:g,neighbors:e,windowHours:h,previousTraceEvidence:d,spreadingFactor:p,localHash:n}),{traceLinks:si,traceLinkSummary:ii,traceDisambiguationFeedback:ri}=oi,Ze=it-at,ci={totalPaths:it,pathsWithGhosts:at,observationOverrideCount:m,avgPathConfidence:Ze>0?w/Ze:0,avgPathCost:0,tracePacketsProcessed:Z,pathPacketsProcessed:et,distantEdgesDiscovered:z,duplicateGroupsFound:v,duplicatePathsUnique:f,echolocationEdgesInferred:_};return{edges:ut,validatedEdges:Ke,weakEdges:Xs,certainEdges:Ke,uncertainEdges:[],edgeMap:re,maxPacketCount:At,maxCertainCount:Wt,neighborAffinity:T,fullAffinity:L,localPrefix:M,centrality:ot,hubNodes:jt,gatewayNodes:$e,loops:zs,loopEdgeKeys:ce,txDelayRecommendations:Qs,pathRegistry:Ht,edgeBetweenness:ae,backboneEdges:Be,nodeMobility:Ye,mobileNodes:Ve,pathHealth:je,lastHopNeighbors:ue,disambiguationStats:Js,discoveredNodes:ze,viterbiStats:ci,nodeMetrics:Qe,communityCount:ei,backboneNodes:ni,traceLinks:si,traceLinkSummary:ii,traceDisambiguationFeedback:ri}}var oe={exports:{}},V={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var ke;function Bs(){if(ke)return V;ke=1;var t=Symbol.for("react.element"),e=Symbol.for("react.portal"),n=Symbol.for("react.fragment"),o=Symbol.for("react.strict_mode"),s=Symbol.for("react.profiler"),i=Symbol.for("react.provider"),a=Symbol.for("react.context"),r=Symbol.for("react.forward_ref"),c=Symbol.for("react.suspense"),l=Symbol.for("react.memo"),g=Symbol.for("react.lazy"),h=Symbol.iterator;function d(m){return m===null||typeof m!="object"?null:(m=h&&m[h]||m["@@iterator"],typeof m=="function"?m:null)}var p={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},E=Object.assign,S={};function v(m,w,j){this.props=m,this.context=w,this.refs=S,this.updater=j||p}v.prototype.isReactComponent={},v.prototype.setState=function(m,w){if(typeof m!="object"&&typeof m!="function"&&m!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,m,w,"setState")},v.prototype.forceUpdate=function(m){this.updater.enqueueForceUpdate(this,m,"forceUpdate")};function f(){}f.prototype=v.prototype;function _(m,w,j){this.props=m,this.context=w,this.refs=S,this.updater=j||p}var C=_.prototype=new f;C.constructor=_,E(C,v.prototype),C.isPureReactComponent=!0;var b=Array.isArray,L=Object.prototype.hasOwnProperty,M={current:null},T={key:!0,ref:!0,__self:!0,__source:!0};function O(m,w,j){var X,z={},Z=null,et=null;if(w!=null)for(X in w.ref!==void 0&&(et=w.ref),w.key!==void 0&&(Z=""+w.key),w)L.call(w,X)&&!T.hasOwnProperty(X)&&(z[X]=w[X]);var nt=arguments.length-2;if(nt===1)z.children=j;else if(1<nt){for(var J=Array(nt),ot=0;ot<nt;ot++)J[ot]=arguments[ot+2];z.children=J}if(m&&m.defaultProps)for(X in nt=m.defaultProps,nt)z[X]===void 0&&(z[X]=nt[X]);return{$$typeof:t,type:m,key:Z,ref:et,props:z,_owner:M.current}}function I(m,w){return{$$typeof:t,type:m.type,key:w,ref:m.ref,props:m.props,_owner:m._owner}}function F(m){return typeof m=="object"&&m!==null&&m.$$typeof===t}function x(m){var w={"=":"=0",":":"=2"};return"$"+m.replace(/[=:]/g,function(j){return w[j]})}var G=/\/+/g;function N(m,w){return typeof m=="object"&&m!==null&&m.key!=null?x(""+m.key):w.toString(36)}function y(m,w,j,X,z){var Z=typeof m;(Z==="undefined"||Z==="boolean")&&(m=null);var et=!1;if(m===null)et=!0;else switch(Z){case"string":case"number":et=!0;break;case"object":switch(m.$$typeof){case t:case e:et=!0}}if(et)return et=m,z=z(et),m=X===""?"."+N(et,0):X,b(z)?(j="",m!=null&&(j=m.replace(G,"$&/")+"/"),y(z,w,j,"",function(ot){return ot})):z!=null&&(F(z)&&(z=I(z,j+(!z.key||et&&et.key===z.key?"":(""+z.key).replace(G,"$&/")+"/")+m)),w.push(z)),1;if(et=0,X=X===""?".":X+":",b(m))for(var nt=0;nt<m.length;nt++){Z=m[nt];var J=X+N(Z,nt);et+=y(Z,w,j,J,z)}else if(J=d(m),typeof J=="function")for(m=J.call(m),nt=0;!(Z=m.next()).done;)Z=Z.value,J=X+N(Z,nt++),et+=y(Z,w,j,J,z);else if(Z==="object")throw w=String(m),Error("Objects are not valid as a React child (found: "+(w==="[object Object]"?"object with keys {"+Object.keys(m).join(", ")+"}":w)+"). If you meant to render a collection of children, use an array instead.");return et}function k(m,w,j){if(m==null)return m;var X=[],z=0;return y(m,X,"","",function(Z){return w.call(j,Z,z++)}),X}function H(m){if(m._status===-1){var w=m._result;w=w(),w.then(function(j){(m._status===0||m._status===-1)&&(m._status=1,m._result=j)},function(j){(m._status===0||m._status===-1)&&(m._status=2,m._result=j)}),m._status===-1&&(m._status=0,m._result=w)}if(m._status===1)return m._result.default;throw m._result}var $={current:null},Y={transition:null},it={ReactCurrentDispatcher:$,ReactCurrentBatchConfig:Y,ReactCurrentOwner:M};function at(){throw Error("act(...) is not supported in production builds of React.")}return V.Children={map:k,forEach:function(m,w,j){k(m,function(){w.apply(this,arguments)},j)},count:function(m){var w=0;return k(m,function(){w++}),w},toArray:function(m){return k(m,function(w){return w})||[]},only:function(m){if(!F(m))throw Error("React.Children.only expected to receive a single React element child.");return m}},V.Component=v,V.Fragment=n,V.Profiler=s,V.PureComponent=_,V.StrictMode=o,V.Suspense=c,V.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=it,V.act=at,V.cloneElement=function(m,w,j){if(m==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+m+".");var X=E({},m.props),z=m.key,Z=m.ref,et=m._owner;if(w!=null){if(w.ref!==void 0&&(Z=w.ref,et=M.current),w.key!==void 0&&(z=""+w.key),m.type&&m.type.defaultProps)var nt=m.type.defaultProps;for(J in w)L.call(w,J)&&!T.hasOwnProperty(J)&&(X[J]=w[J]===void 0&&nt!==void 0?nt[J]:w[J])}var J=arguments.length-2;if(J===1)X.children=j;else if(1<J){nt=Array(J);for(var ot=0;ot<J;ot++)nt[ot]=arguments[ot+2];X.children=nt}return{$$typeof:t,type:m.type,key:z,ref:Z,props:X,_owner:et}},V.createContext=function(m){return m={$$typeof:a,_currentValue:m,_currentValue2:m,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},m.Provider={$$typeof:i,_context:m},m.Consumer=m},V.createElement=O,V.createFactory=function(m){var w=O.bind(null,m);return w.type=m,w},V.createRef=function(){return{current:null}},V.forwardRef=function(m){return{$$typeof:r,render:m}},V.isValidElement=F,V.lazy=function(m){return{$$typeof:g,_payload:{_status:-1,_result:m},_init:H}},V.memo=function(m,w){return{$$typeof:l,type:m,compare:w===void 0?null:w}},V.startTransition=function(m){var w=Y.transition;Y.transition={};try{m()}finally{Y.transition=w}},V.unstable_act=at,V.useCallback=function(m,w){return $.current.useCallback(m,w)},V.useContext=function(m){return $.current.useContext(m)},V.useDebugValue=function(){},V.useDeferredValue=function(m){return $.current.useDeferredValue(m)},V.useEffect=function(m,w){return $.current.useEffect(m,w)},V.useId=function(){return $.current.useId()},V.useImperativeHandle=function(m,w,j){return $.current.useImperativeHandle(m,w,j)},V.useInsertionEffect=function(m,w){return $.current.useInsertionEffect(m,w)},V.useLayoutEffect=function(m,w){return $.current.useLayoutEffect(m,w)},V.useMemo=function(m,w){return $.current.useMemo(m,w)},V.useReducer=function(m,w,j){return $.current.useReducer(m,w,j)},V.useRef=function(m){return $.current.useRef(m)},V.useState=function(m){return $.current.useState(m)},V.useSyncExternalStore=function(m,w,j){return $.current.useSyncExternalStore(m,w,j)},V.useTransition=function(){return $.current.useTransition()},V.version="18.3.1",V}var Le;function Ys(){return Le||(Le=1,oe.exports=Bs()),oe.exports}Ys(),self.onmessage=t=>{const{type:e,payload:n}=t.data;if(e!=="compute"){self.postMessage({type:"error",error:`Unknown message type: ${e}`});return}const o=performance.now();try{const{packets:s,neighbors:i,localHash:a,localLat:r,localLon:c,airtimeMs:l,zeroHopNeighbors:g,terrainGrid:h,enableTerrainAware:d,srcHashResolverEntries:p,windowHours:E,spreadingFactor:S,previousTraceEvidenceSerialized:v}=n,f=p&&p.length>0?new Map(p):void 0,_=v?{confirmedResolutions:new Map(v.confirmedResolutions),confirmedLinks:v.confirmedLinks}:void 0,C=Ks(s,i,a,.5,r,c,l,g,h,d,f,E,_,S),b=h?{enabled:!0,totalLinks:0,feasibleLinks:0,blockedLinks:0,overriddenLinks:0,reasonCounts:{}}:void 0,L={edges:C.edges,validatedEdges:C.validatedEdges,weakEdges:C.weakEdges,certainEdges:C.certainEdges,uncertainEdges:C.uncertainEdges,maxPacketCount:C.maxPacketCount,maxCertainCount:C.maxCertainCount,localPrefix:C.localPrefix,hubNodes:C.hubNodes,gatewayNodes:C.gatewayNodes,edgeMapEntries:Array.from(C.edgeMap.entries()),neighborAffinityEntries:Array.from(C.neighborAffinity.entries()),fullAffinityEntries:Array.from(C.fullAffinity.entries()),centralityEntries:Array.from(C.centrality.entries()),loops:C.loops,loopEdgeKeyEntries:Array.from(C.loopEdgeKeys),txDelayRecommendationEntries:Array.from(C.txDelayRecommendations.entries()),pathRegistry:Ao(C.pathRegistry),edgeBetweennessEntries:Array.from(C.edgeBetweenness.entries()),backboneEdges:C.backboneEdges,nodeMobilityEntries:Array.from(C.nodeMobility.entries()),mobileNodes:C.mobileNodes,pathHealth:C.pathHealth,lastHopNeighbors:C.lastHopNeighbors,disambiguationStats:C.disambiguationStats,discoveredNodes:C.discoveredNodes,viterbiStats:C.viterbiStats,nodeMetricsEntries:Array.from(C.nodeMetrics.entries()),communityCount:C.communityCount,backboneNodes:C.backboneNodes,traceLinkEntries:Array.from(C.traceLinks.entries()),traceLinkSummary:C.traceLinkSummary,traceDisambiguationFeedbackEntries:{confirmedResolutions:Array.from(C.traceDisambiguationFeedback.confirmedResolutions.entries()),confirmedLinks:C.traceDisambiguationFeedback.confirmedLinks},terrainStats:b},M=performance.now()-o,T={type:"result",payload:L,computeTimeMs:M};self.postMessage(T)}catch(s){const i={type:"error",error:s instanceof Error?s.message:"Unknown error in topology worker"};self.postMessage(i)}}})();
