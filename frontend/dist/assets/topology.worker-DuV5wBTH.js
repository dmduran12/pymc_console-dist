!function(){"use strict";function t(t){return 1===t||0===t}function e(t){return 2===t||3===t}function o(t){return t.startsWith("0x")||t.startsWith("0X")?t.slice(2,4).toUpperCase():t.slice(0,2).toUpperCase()}function n(t,e){let n=t.forwarded_path??t.original_path;if("string"==typeof n)try{n=JSON.parse(n)}catch{return null}if(!n||!Array.isArray(n)||0===n.length)return null;const s=n.map(t=>String(t).toUpperCase()),i=e?o(e):null,a=s[s.length-1],r=null!==i&&a===i,c=r?s.slice(0,-1):[...s];return{effective:c,original:s,hadLocal:r,effectiveLength:c.length}}function s(t,e){return e-t}function i(t){return t}function a(t,e){const o=t.toUpperCase();return e.startsWith("0x")||e.startsWith("0X")?e.slice(2).toUpperCase().startsWith(o):e.toUpperCase().startsWith(o)}function r(t,e,o,n){const s=(o-t)*Math.PI/180,i=(n-e)*Math.PI/180,a=Math.sin(s/2)*Math.sin(s/2)+Math.cos(t*Math.PI/180)*Math.cos(o*Math.PI/180)*Math.sin(i/2)*Math.sin(i/2);return 2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a))*6371e3}function c(t){return t<500?1:t<2e3?.8:t<5e3?.6:t<1e4?.4:t<2e4?.2:.1}function h(t){if(t.contact_type){const e=t.contact_type.toLowerCase();if("repeater"===e||"rep"===e)return!0;if("companion"===e||"client"===e||"cli"===e)return!1;if("room server"===e||"room_server"===e||"room"===e||"server"===e)return!1}return!0===t.is_repeater||(t.is_repeater,!1)}function u(t,e){if(!t||t<=0)return.1;const o=(Math.floor(Date.now()/1e3)-t)/3600;return o<0?1:Math.exp(-o/12)}function l(t){return!(!t||t<=0)&&(Math.floor(Date.now()/1e3)-t)/3600>336}function f(t,e,o){const n=e.toUpperCase(),s=t.get(n);if(!s||0===s.candidates.length)return{hash:null,confidence:0};if(null==o?void 0:o.isLastHop)return{hash:s.bestMatch,confidence:s.confidence};if(1===(null==o?void 0:o.position))return{hash:s.bestMatch,confidence:s.confidence};if((null==o?void 0:o.position)&&s.bestMatchForPosition.has(o.position)){const t=s.bestMatchForPosition.get(o.position),e=Math.max(t.confidence,s.confidence);return{hash:t.hash,confidence:e}}if((null==o?void 0:o.adjacentPrefixes)&&o.adjacentPrefixes.length>0){let t=s.bestMatch,e=0;for(const n of s.candidates){let s=0;for(const t of o.adjacentPrefixes)s+=n.adjacentPrefixCounts.get(t.toUpperCase())||0;const i=n.combinedScore+s/Math.max(1,n.totalAdjacentObservations)*.3;i>e&&(e=i,t=n.hash)}return{hash:t,confidence:s.confidence}}return{hash:s.bestMatch,confidence:s.confidence}}function d(t,e){return`${e}:${t.join(">")}`}function p(t,e){return`${t}→${e}`}function g(o){const n=o.route??o.route_type;return t(n)?"flood":e(n)?"direct":"unknown"}const m=100;function C(t,e){return[t,e].sort().join("-")}function y(y,S,v,b=.4,M,w,P){const x=[...y].sort((t,e)=>(t.timestamp??0)-(e.timestamp??0)),H=function(t,e,i,a,c){const f=new Map,d=function(t){const e={};for(const[o,n]of Object.entries(t))h(n)&&(e[o]=n);return e}(e),p=new Map,g=void 0!==a&&void 0!==c&&(0!==a||0!==c);if(i){const t=o(i),e={hash:i,prefix:t,positionCounts:new Array(5).fill(0),totalAppearances:0,typicalPosition:0,positionConsistency:0,adjacentPrefixCounts:new Map,totalAdjacentObservations:0,latitude:a,longitude:c,distanceToLocal:0,srcGeoEvidenceScore:0,srcGeoEvidenceCount:0,lastSeenTimestamp:Math.floor(Date.now()/1e3),recencyScore:1,positionScore:0,cooccurrenceScore:0,geographicScore:1,combinedScore:0};p.set(t,[e])}for(const[n,s]of Object.entries(d)){const t=o(n),e=s.last_seen??0;if(l(e))continue;let i;const h=!0===s.zero_hop;g&&s.latitude&&s.longitude&&(0!==s.latitude||0!==s.longitude)&&(i=r(a,c,s.latitude,s.longitude));let f=.2;void 0!==i?f=i<500?1:i<2e3?.8:i<5e3?.6:i<1e4?.4:i<2e4?.2:.1:s.latitude&&s.longitude&&(f=.5),h&&(f=Math.max(f,.95));const d=u(e),m={hash:n,prefix:t,positionCounts:new Array(5).fill(0),totalAppearances:0,typicalPosition:0,positionConsistency:0,adjacentPrefixCounts:new Map,totalAdjacentObservations:0,latitude:s.latitude,longitude:s.longitude,distanceToLocal:i,srcGeoEvidenceScore:0,srcGeoEvidenceCount:0,lastSeenTimestamp:e,recencyScore:d,positionScore:0,cooccurrenceScore:0,geographicScore:f,combinedScore:0},C=p.get(t)||[];C.push(m),p.set(t,C)}for(const o of t){const t=n(o,i);if(!t||0===t.effectiveLength)continue;const a=t.effective,c=o.src_hash,h=c?e[c]:void 0,u=(null==h?void 0:h.latitude)&&(null==h?void 0:h.longitude)&&(0!==h.latitude||0!==h.longitude);for(let e=0;e<a.length;e++){const o=a[e],n=p.get(o);if(!n)continue;const i=s(e,t.effectiveLength),c=Math.min(i-1,4);for(const t of n){if(t.positionCounts[c]++,t.totalAppearances++,1===i&&n.length>1&&u&&t.latitude&&t.longitude){const e=r(h.latitude,h.longitude,t.latitude,t.longitude);let o=0;o=e<500?1:e<2e3?.8:e<5e3?.5:e<1e4?.3:.1,void 0!==t.distanceToLocal&&(t.distanceToLocal<500?o*=1.2:t.distanceToLocal<2e3?o*=1:o*=.8),t.srcGeoEvidenceScore+=o,t.srcGeoEvidenceCount++}if(e>0&&n.length>1&&t.latitude&&t.longitude){const o=a[e-1],n=p.get(o);if(n&&n.length>0){let e,o,s=0;if(1===n.length){const t=n[0];t.latitude&&t.longitude&&(e=t.latitude,o=t.longitude,s=1)}else{const t=[...n].sort((t,e)=>e.combinedScore-t.combinedScore),i=t[0],a=t[1];if(i.latitude&&i.longitude&&i.combinedScore>0){const t=a?(i.combinedScore-a.combinedScore)/i.combinedScore:1;s=Math.min(1,t+.3),s>.4&&(e=i.latitude,o=i.longitude)}}if(void 0!==e&&void 0!==o){const n=r(t.latitude,t.longitude,e,o);let i=0;i=n<500?1:n<2e3?.8:n<5e3?.5:n<1e4?.3:.1,i*=s,t.srcGeoEvidenceScore+=i,t.srcGeoEvidenceCount++}}}if(i>1&&n.length>1&&t.latitude&&t.longitude){const o=e+1;if(o<a.length){const e=a[o],n=p.get(e);if(n&&n.length>0){let e,o,s=0;if(1===n.length){const t=n[0];t.latitude&&t.longitude&&(e=t.latitude,o=t.longitude,s=1)}else{const t=[...n].sort((t,e)=>e.combinedScore-t.combinedScore),i=t[0],a=t[1];if(i.latitude&&i.longitude&&i.combinedScore>0){const t=a?(i.combinedScore-a.combinedScore)/i.combinedScore:1;s=Math.min(1,t+.3),s>.4&&(e=i.latitude,o=i.longitude)}}if(void 0!==e&&void 0!==o){const n=r(t.latitude,t.longitude,e,o);let i=0;i=n<500?1:n<2e3?.8:n<5e3?.5:n<1e4?.3:.1,i*=s,t.srcGeoEvidenceScore+=i,t.srcGeoEvidenceCount++}}}}if(e>0){const o=a[e-1];t.adjacentPrefixCounts.set(o,(t.adjacentPrefixCounts.get(o)||0)+1),t.totalAdjacentObservations++}if(e<a.length-1){const o=a[e+1];t.adjacentPrefixCounts.set(o,(t.adjacentPrefixCounts.get(o)||0)+1),t.totalAdjacentObservations++}}}}let m=1,C=1;for(const o of p.values())for(const t of o)m=Math.max(m,t.totalAppearances),C=Math.max(C,t.totalAdjacentObservations);for(const o of p.values())for(const t of o){if(t.totalAppearances>0){let e=0,o=1;for(let s=0;s<5;s++)t.positionCounts[s]>e&&(e=t.positionCounts[s],o=s+1);t.typicalPosition=o,t.positionConsistency=e/t.totalAppearances;const n=t.totalAppearances/m;t.positionScore=.6*t.positionConsistency+.4*n}if(t.totalAdjacentObservations>0&&(t.cooccurrenceScore=t.totalAdjacentObservations/C),t.combinedScore=.15*t.positionScore+.15*t.cooccurrenceScore+.35*t.geographicScore+.35*t.recencyScore,t.srcGeoEvidenceCount>0){const e=t.srcGeoEvidenceScore/t.srcGeoEvidenceCount*Math.min(t.srcGeoEvidenceCount/50,1)*.3;t.combinedScore+=e}}for(const[o,n]of p){n.sort((t,e)=>e.combinedScore-t.combinedScore);const t=n.length>0?n[0].hash:null;let e=0;if(1===n.length)e=1;else if(n.length>1){const t=n[0].combinedScore,o=n[1].combinedScore;t>0&&(e=Math.min(1,(t-o)/t)),n[0].totalAppearances>2*n[1].totalAppearances&&(e=Math.min(1,e+.2));const s=0,i=n[0].positionCounts[s]||0,a=i+(n[1].positionCounts[s]||0);if(a>=20&&i>=10){const t=i/a;if(t>=.8){const o=.3+1.5*(t-.8);e=Math.min(1,e+o)}}const r=n.reduce((t,e)=>t+e.combinedScore,0);if(r>0){const t=[],o=n.reduce((t,e)=>t+(e.positionCounts[0]||0),0);for(const e of n){const n=o*(e.combinedScore/r);t.push(n)}const s=t[0],i=s+(t[1]||0);if(i>=20&&s>=10){const t=s/i;if(t>=.6){const o=.2+1*(t-.6);e=Math.min(1,e+o)}}}const c=n[0].srcGeoEvidenceScore,h=n[1].srcGeoEvidenceScore;if(n[0].srcGeoEvidenceCount>=10&&c>1.5*h){const t=h>0?c/(c+h):1,o=Math.min(.3,.6*(t-.5));e=Math.min(1,e+o)}}const s=new Map;for(let o=1;o<=5;o++){const t=[...n].sort((t,e)=>{const n=t.positionCounts[o-1]||0;return(e.positionCounts[o-1]||0)-n});if(t.length>0&&t[0].positionCounts[o-1]>0){const e=t[0];let n=1;if(t.length>1){const s=e.positionCounts[o-1],i=s+(t[1].positionCounts[o-1]||0);n=i>0?s/i:0}s.set(o,{hash:e.hash,confidence:n})}}const i={prefix:o,candidates:n,bestMatch:t,confidence:e,isUnambiguous:1===n.length,bestMatchForPosition:s};f.set(o,i)}return f}(x,S,v,M,w),k=function(t,e,o,i,h,u){const l=new Map,d=void 0!==o&&void 0!==i&&(0!==o||0!==i);for(const[n,s]of Object.entries(e)){let t=null,e=.5;d&&s.latitude&&s.longitude&&(0!==s.latitude||0!==s.longitude)&&(t=r(o,i,s.latitude,s.longitude),e=c(t)),s.zero_hop&&(e=Math.max(e,.9)),l.set(n,{hash:n,frequency:0,directForwardCount:0,distanceMeters:t,proximityScore:e,hopPositionCounts:[0,0,0,0,0],avgHopDistance:0,typicalHopPosition:0,hopConsistencyScore:0,frequencyScore:0,combinedScore:0,avgDisambiguationConfidence:0,collisionCount:0,resolutionCount:0})}const p=new Map;for(const r of t){const t=n(r,h);if(t&&t.effectiveLength>=1){const e=t.effective;for(let o=0;o<e.length;o++){const n=e[o],i=s(o,t.effectiveLength);if(u){const t=f(u,n,{position:i,adjacentPrefixes:[...o>0?[e[o-1]]:[],...o<e.length-1?[e[o+1]]:[]],isLastHop:1===i});if(t.hash){const e=l.get(t.hash);if(e){e.frequency++,e.resolutionCount++;const o=p.get(t.hash)||0;p.set(t.hash,o+t.confidence);const s=u.get(n.toUpperCase());s&&!s.isUnambiguous&&e.collisionCount++;const a=Math.min(i-1,4);e.hopPositionCounts[a]++,1===i&&e.directForwardCount++}}}else for(const[t,e]of l)if(a(n,t)){e.frequency++;const t=Math.min(i-1,4);e.hopPositionCounts[t]++,1===i&&e.directForwardCount++}}}if((!t||0===t.effectiveLength)&&r.src_hash){const t=l.get(r.src_hash);if(t){t.frequency++,t.directForwardCount++,t.hopPositionCounts[0]++,t.resolutionCount++;const e=p.get(r.src_hash)||0;p.set(r.src_hash,e+1)}}}let g=0;for(const n of l.values())g=Math.max(g,n.frequency);for(const n of l.values()){let t=0,e=0,o=0,s=1;for(let a=0;a<n.hopPositionCounts.length;a++){const i=n.hopPositionCounts[a],r=a+1;t+=i,e+=i*r,i>o&&(o=i,s=r)}n.avgHopDistance=t>0?e/t:0,n.typicalHopPosition=s,t>0&&o>0&&(n.hopConsistencyScore=o/t),n.frequencyScore=g>0?n.frequency/g:0;const i=p.get(n.hash)||0;n.avgDisambiguationConfidence=n.resolutionCount>0?i/n.resolutionCount:0,n.combinedScore=.3*n.proximityScore+.3*n.hopConsistencyScore+.4*n.frequencyScore}return l}(x,S,M,w,v,H),E=v?o(v):null,D=new Map;for(const[t,e]of k)D.set(t,e.combinedScore);const A=new Map,L=new Map,R=new Map,j=new Map,U=new Map,N=Math.floor(Date.now()/1e3),_=(o,n,s,i,a,r,c)=>{const h=C(o,n),u=A.get(h),[l,f]=o<n?[o,n]:[n,o],d=o===l,p=t(r)||void 0===r,g=e(r),m=(t=>{if(!t||t<=0)return.1;const e=(N-t)/3600;return e<0?1:Math.exp(-e/12)})(c);if(u)u.count++,u.confidenceSum+=s,u.recencySum+=m,u.minHopDistance=Math.min(u.minHopDistance,a),a<u.hopDistanceCounts.length&&u.hopDistanceCounts[a]++,i?u.certainCount++:u.uncertainCount++,d?u.forwardCount++:u.reverseCount++,p?u.floodCount++:g&&u.directCount++;else{const t=[0,0,0,0,0,0,0,0,0,0];a<t.length&&t[a]++,A.set(h,{fromHash:l,toHash:f,key:h,count:1,confidenceSum:s,minHopDistance:a,hopDistanceCounts:t,certainCount:i?1:0,uncertainCount:i?0:1,forwardCount:d?1:0,reverseCount:d?0:1,floodCount:p?1:0,directCount:g?1:0,recencySum:m})}};for(const t of x){const e=n(t,v);if(!e)continue;const o=e.effective,a=e.effectiveLength,r=e.original,c=new Set;if(t.src_hash&&r.length>=1){const e=f(H,r[0],{position:a,adjacentPrefixes:r.length>1?[r[1]]:[]}),o=t.src_hash;if(e.hash&&e.hash!==o){const n=Object.keys(S).includes(o),s=e.confidence>=.6&&n,i=e.confidence*(n?1:.8),r=a+1,h=t.route??t.route_type;_(o,e.hash,i,s,r,h,t.timestamp),c.add(o),c.add(e.hash)}}if(v&&a>=1){const e=a-1,n=o[e],s=4===(t.type??t.payload_type);if(s){const e=U.get(n);e?(e.count++,"number"!=typeof t.rssi||isNaN(t.rssi)||(e.rssiSum+=t.rssi,e.rssiCount++),"number"!=typeof t.snr||isNaN(t.snr)||(e.snrSum+=t.snr,e.snrCount++),e.lastSeen=Math.max(e.lastSeen,t.timestamp??0)):U.set(n,{prefix:n,count:1,rssiSum:"number"!=typeof t.rssi||isNaN(t.rssi)?0:t.rssi,rssiCount:"number"!=typeof t.rssi||isNaN(t.rssi)?0:1,snrSum:"number"!=typeof t.snr||isNaN(t.snr)?0:t.snr,snrCount:"number"!=typeof t.snr||isNaN(t.snr)?0:1,lastSeen:t.timestamp??0,resolvedHashes:new Map})}const i=f(H,n,{position:1,adjacentPrefixes:e>0?[o[e-1]]:[],isLastHop:!0});if(s&&i.hash){const t=U.get(n);if(t){const e=t.resolvedHashes.get(i.hash);e?(e.count++,e.confidenceSum+=i.confidence):t.resolvedHashes.set(i.hash,{count:1,confidenceSum:i.confidence})}}if(i.hash&&i.hash!==v){const e=!0,o=i.confidence,n=t.route??t.route_type;_(i.hash,v,o,e,0,n,t.timestamp),c.add(i.hash),c.add(v),j.set(i.hash,(j.get(i.hash)||0)+1)}}for(let n=0;n<a-1;n++){const e=o[n],r=o[n+1],h=s(n,a),u=s(n+1,a),l=1===u,d=f(H,e,{position:h,adjacentPrefixes:[...n>0?[o[n-1]]:[],o[n+1]]}),p=f(H,r,{position:u,adjacentPrefixes:[o[n],...n+2<a?[o[n+2]]:[]],isLastHop:l});if(!d.hash||!p.hash)continue;if(d.hash===p.hash)continue;const g=d.confidence>=.6&&p.confidence>=.6,m=p.confidence>=.9,C=l&&p.confidence>=.6,y=g||m||C;c.add(d.hash),c.add(p.hash),n>0&&n<a-1&&R.set(d.hash,(R.get(d.hash)||0)+1);const S=m?p.confidence:d.confidence*p.confidence;if(!y&&S<b)continue;const v=i(u),M=t.route??t.route_type;_(d.hash,p.hash,S,y,v,M,t.timestamp)}for(const t of c)L.set(t,(L.get(t)||0)+1)}const F=new Map;let T=0;for(const[t,e]of L){const o=R.get(t)||0,n=e>0?o/e:0;F.set(t,n),T=Math.max(T,n)}if(T>0)for(const[t,e]of F)F.set(t,e/T);const G=Math.max(5,Math.floor(.01*y.length)),O=new Set,$=new Map;for(const t of A.values()){const e=t.forwardCount+t.reverseCount>0?Math.min(t.forwardCount,t.reverseCount)/Math.max(t.forwardCount,t.reverseCount):0;for(const o of[t.fromHash,t.toHash]){const t=$.get(o)||{sum:0,count:0};t.sum+=e,t.count++,$.set(o,t)}}const q=[...F.entries()].filter(([t,e])=>(L.get(t)||0)>=G).map(([t,e])=>{const o=$.get(t),n=o&&o.count>0?o.sum/o.count:0;return{hash:t,effectiveScore:e+.2*n,rawScore:e,avgSymmetry:n}}).sort((t,e)=>e.effectiveScore-t.effectiveScore);for(const{hash:t,effectiveScore:e,rawScore:o,avgSymmetry:n}of q)(e>=.5||o>=.35&&n>=.7)&&O.add(t);const z=Math.min(100,Math.floor(.05*y.length)),I=Math.max(...j.values(),1);for(const[t,e]of j){if(t===v)continue;if(O.has(t))continue;const o=$.get(t),n=e/I;if(e>=((o&&o.count>0?o.sum/o.count:0)>=.6?Math.floor(.7*z):z)||n>=.5){O.add(t);const o=e/(L.get(t)||e),n=F.get(t)||0;F.set(t,Math.max(n,o))}}const W=Array.from(O),K=[],B=[],V=[];let X=0,J=0;const Q=new Set(W),Y=new Set;for(const t of A.values()){const e=t.confidenceSum/t.count;X=Math.max(X,t.count),J=Math.max(J,t.certainCount);const o=Q.has(t.fromHash)||Q.has(t.toHash),n=t.certainCount>=5,s=t.forwardCount+t.reverseCount,i=s>0?Math.min(t.forwardCount,t.reverseCount)/Math.max(t.forwardCount,t.reverseCount):0;let a="balanced";i<.7&&s>0&&(a=t.forwardCount>t.reverseCount?"forward":"reverse");const r=t.floodCount+t.directCount>0&&t.directCount>t.floodCount,c=t.count>0?t.recencySum/t.count:0,h={fromHash:t.fromHash,toHash:t.toHash,key:t.key,packetCount:t.count,avgConfidence:e,strength:0,avgRecency:c,hopDistanceFromLocal:t.minHopDistance,isHubConnection:o,isCertain:n,certainCount:t.certainCount,forwardCount:t.forwardCount,reverseCount:t.reverseCount,symmetryRatio:i,dominantDirection:a,floodCount:t.floodCount,directCount:t.directCount,isDirectPathEdge:r};K.push(h),n&&(B.push(h),Y.add(t.key))}for(const t of K)!Y.has(t.key)&&t.packetCount>=2&&V.push(t);for(const t of K){const e=X>0?t.packetCount/X:0;t.strength=.4*e+.4*t.avgConfidence+.2*t.avgRecency}K.sort((t,e)=>e.certainCount-t.certainCount),B.sort((t,e)=>{const o=t.certainCount+(t.isHubConnection?1e3:0);return e.certainCount+(e.isHubConnection?1e3:0)-o}),V.sort((t,e)=>t.packetCount-e.packetCount);const Z=B.slice(0,100),tt=V.slice(0,100),et=new Map(K.map(t=>[t.key,t])),{loops:ot,loopEdgeKeys:nt}=function(t,e,o=1){if(t.length<3)return{loops:[],loopEdgeKeys:new Set};const n=new Map,s=new Map;for(const h of t)s.set(h.key,h),n.has(h.fromHash)||n.set(h.fromHash,new Set),n.has(h.toHash)||n.set(h.toHash,new Set),n.get(h.fromHash).add(h.toHash),n.get(h.toHash).add(h.fromHash);const i=[],a=new Set,r=new Set;function c(t,e,o){if(t===e)return[t];const s=new Set([t]),i=[{node:t,path:[t]}];for(;i.length>0;){const{node:t,path:a}=i.shift(),r=n.get(t);if(r)for(const n of r)if(C(t,n)!==o){if(n===e)return[...a,n];s.has(n)||(s.add(n),i.push({node:n,path:[...a,n]}))}}return null}for(const h of t){const t=c(h.fromHash,h.toHash,h.key);if(t&&t.length>=2){const n=t,c=[h.key];for(let e=0;e<t.length-1;e++){const o=C(t[e],t[e+1]);c.push(o)}const u=[...n].sort().join(",");if(r.has(u))continue;r.add(u);let l=0,f=1/0;for(const t of c){const e=s.get(t);e&&(l+=e.certainCount,f=Math.min(f,e.certainCount),a.add(t))}const d=c.length>0?l/c.length:0,p=!!e&&n.includes(e),g={id:`loop-${i.length}`,edgeKeys:c,nodes:n,size:c.length,avgCertainCount:d,minCertainCount:f===1/0?0:f,includesLocal:p,strength:o>0?f===1/0?0:f/o:0};i.push(g)}}return i.sort((t,e)=>t.includesLocal!==e.includesLocal?t.includesLocal?-1:1:e.strength-t.strength),{loops:i,loopEdgeKeys:a}}(B,v,J);for(const t of K)t.isLoopEdge=nt.has(t.key);const st=function(t,e){const o=new Map,n=new Map;let s=0;for(const r of t){if(!r.src_hash)continue;const t=r.original_path??r.forwarded_path;if(!t||!Array.isArray(t)||0===t.length)continue;const n=t.map(t=>"string"==typeof t?t.toUpperCase().slice(0,2):String(t).toUpperCase().slice(0,2)),i=e||"unknown",a=r.src_hash,c=d(n,a);let h=o.get(c);h||(h={id:c,hops:n,srcHash:a,dstHash:i,observationCount:0,firstSeen:r.timestamp,lastSeen:r.timestamp,routeType:g(r),hopCount:n.length},o.set(c,h)),h.observationCount++,h.lastSeen=Math.max(h.lastSeen,r.timestamp),h.firstSeen=Math.min(h.firstSeen,r.timestamp),s++,"direct"===g(r)&&"direct"!==h.routeType&&(h.routeType="direct")}const i=Array.from(o.values());for(const r of i){const t=p(r.srcHash,r.dstHash),e=n.get(t)||[];e.push(r),n.set(t,e)}for(const r of n.values())r.sort((t,e)=>e.observationCount-t.observationCount);const a=new Map;for(const[r,c]of n)c.length>0&&a.set(r,c[0]);return{paths:i,byEndpoints:n,canonicalPaths:a,totalObservations:s,uniquePathCount:i.length}}(x,v),it=function(t,e,o,n){const s=new Map;if(0===t.length||0===o.length)return s;const i=t=>{const e=.2*Math.round(t/.2);return Math.max(0,Math.min(5,e))},a=t=>Math.floor(5*t),r=new Set;for(const m of t)r.add(m.fromHash),r.add(m.toHash);const c=o.map(t=>t.timestamp).filter(t=>void 0!==t&&t>0).sort((t,e)=>t-e),h=c.length>=2?(c[c.length-1]-c[0])/60:1,u=new Map;for(const m of t)u.has(m.fromHash)||u.set(m.fromHash,[]),u.has(m.toHash)||u.set(m.toHash,[]),u.get(m.fromHash).push(m),u.get(m.toHash).push(m);const l=new Set;for(const m of t)m.isLoopEdge&&l.add(m.key);const f=new Set;for(const[,m]of n.canonicalPaths)for(const t of m.hops)f.add(t.toUpperCase());const d=new Map;for(const m of r){const t=u.get(m)||[];if(0===t.length)continue;const e=m.startsWith("0x")?m.slice(2,4).toUpperCase():m.slice(0,2).toUpperCase(),o=new Set;let s=0,i=0,a=0,r=0,c=0,f=0,p=0;for(const n of t){const t=n.fromHash===m?n.toHash:n.fromHash;o.add(t),s+=n.packetCount,i+=n.certainCount,a=Math.max(a,n.certainCount),r+=n.symmetryRatio,c+=n.floodCount,n.isDirectPathEdge&&f++,l.has(n.key)&&p++}const g=o.size,C=t.length>0?r/t.length:0,y=t.length>0?i/t.length:0,S=n.paths.filter(t=>t.hops.some(t=>t.toUpperCase()===e)),v=S.length;let b=0;for(const[,h]of n.canonicalPaths)h.hops.some(t=>t.toUpperCase()===e)&&b++;const M=S.length>0?S.reduce((t,e)=>t+e.hopCount,0)/S.length:0;d.set(m,{neighborCount:g,totalEdgePackets:s,maxEdgeCertainCount:a,avgEdgeCertainCount:y,avgSymmetry:C,forwardingBurden:0,floodForwardRatio:s>0?c/s:0,pathCount:v,canonicalPathCount:b,avgPathLength:M,loopParticipation:t.length>0?p/t.length:0,isInLoop:p>0,edgeDensity:0,trafficRate:h>0?s/h:0,directPathEdgeRatio:t.length>0?f/t.length:0})}const p=[],g=[],C=[],y=[];for(const[,P]of d)P.totalEdgePackets>=m&&(p.push(P.totalEdgePackets),g.push(P.neighborCount),C.push(P.pathCount),y.push(P.trafficRate));p.sort((t,e)=>t-e),g.sort((t,e)=>t-e),C.sort((t,e)=>t-e),y.sort((t,e)=>t-e);const S=(t,e)=>{if(0===t.length)return.5;const o=t.findIndex(t=>t>=e);return-1===o?1:0===o?0:o/t.length},v=g.length>0?Math.max(...g):1;for(const[,m]of d)m.forwardingBurden=S(p,m.totalEdgePackets),m.edgeDensity=v>0?m.neighborCount/v:0;const b=new Map;for(const P of r){const t=d.get(P);if(!t||t.totalEdgePackets<m)continue;const e=P.startsWith("0x")?P.slice(2,4).toUpperCase():P.slice(0,2).toUpperCase(),s=t.forwardingBurden,i=S(g,t.neighborCount),a=.3*t.avgSymmetry,r=Math.min(1,i+a),c=.6*(n.canonicalPaths.size>0?t.canonicalPathCount/n.canonicalPaths.size:0)+.4*S(C,t.pathCount),h=t.loopParticipation,u=.3*s+.3*r+.2*c+.2*h;let l,f=.4+3.6*u;(u<.1&&t.neighborCount<=2||f<.4)&&(f=.4),l=u>=.7&&t.neighborCount>=4?"backbone":t.neighborCount>=4?"hub":u>=.3&&t.neighborCount>=2?"relay":"edge";const p=n.paths.filter(t=>t.hops.some(t=>t.toUpperCase()===e)).flatMap(t=>{const o=t.hops.findIndex(t=>t.toUpperCase()===e);return o>=0?[o+1]:[]}),y=p.length>0?p.reduce((t,e)=>t+e,0)/p.length:0;let v=0;p.length>1&&(v=p.reduce((t,e)=>t+Math.pow(e-y,2),0)/p.length);const M=.3*Math.min(t.avgEdgeCertainCount/10,1)+.3*Math.min(o.length/1e3,1)+.4*t.avgSymmetry;let w;w=o.length<m?"insufficient":o.length<500?"low":o.length<1e3?"medium":"high",b.set(P,{compositeScore:u,rawFloodDelay:f,networkRole:l,collisionRisk:r,floodParticipationRate:t.floodForwardRatio,avgPathPosition:y,pathPositionVariance:v,pathDiversity:t.pathCount,trafficIntensity:t.trafficRate,confidence:M,observationSymmetry:t.avgSymmetry,dataConfidence:w,factors:{forwarding:s,collision:r,criticality:c,redundancy:h}})}const M=new Map;for(const[m,P]of b){const t=a(i(P.rawFloodDelay));M.has(t)||M.set(t,[]),M.get(t).push(m)}const w=new Map;for(const[,m]of M){if(m.length<=1){if(1===m.length){const t=m[0],e=b.get(t);w.set(t,i(e.rawFloodDelay))}continue}const t=[...m].sort((t,e)=>{const o=b.get(t),n=b.get(e);return o.compositeScore-n.compositeScore});for(let e=0;e<t.length;e++){const o=t[e],n=b.get(o),s=e%3*.2;w.set(o,i(n.rawFloodDelay+s))}}for(const P of r){const t=d.get(P);if(!t||t.totalEdgePackets<m){s.set(P,{floodFactor:0,directFactor:0,floodSlots:0,directSlots:0,floodDelaySec:0,directDelaySec:0,txDelayFactor:0,directTxDelayFactor:0,trafficIntensity:0,directNeighborCount:(null==t?void 0:t.neighborCount)??0,collisionRisk:0,confidence:0,insufficientData:!0,networkRole:"edge",rationale:"Insufficient data (<100 packets observed)",adjustment:"stable",avgPathPosition:0,pathPositionVariance:0,floodParticipationRate:0,pathDiversity:0,positionDelayMs:0,observationSymmetry:(null==t?void 0:t.avgSymmetry)??0,dataConfidence:"insufficient"});continue}const e=b.get(P),o=w.get(P)??i(e.rawFloodDelay),n=i(.28*o),r=a(o),c=a(n);let h,u={backbone:`Backbone: ${t.neighborCount} neighbors, ${Math.round(100*t.avgSymmetry)}% symmetric`,hub:`Hub: ${t.neighborCount} neighbors`,relay:`Relay: ${Math.round(100*t.avgSymmetry)}% symmetric traffic`,edge:"Edge node"}[e.networkRole];e.observationSymmetry>=.6?u+=". High bidirectional visibility (+1 slot)":e.observationSymmetry<.3&&(u+=". ⚠️ Low symmetry (possible observer bias)"),"low"===e.dataConfidence&&(u+=". Limited data"),h=r>a(1)?"increase":r<a(1)?"decrease":"stable";const l=0;s.set(P,{floodFactor:o,directFactor:n,floodSlots:r,directSlots:c,floodDelaySec:o,directDelaySec:n,txDelayFactor:o,directTxDelayFactor:n,trafficIntensity:Math.round(10*e.trafficIntensity)/10,directNeighborCount:t.neighborCount,collisionRisk:Math.round(100*e.collisionRisk)/100,confidence:e.confidence,insufficientData:!1,networkRole:e.networkRole,rationale:u,adjustment:h,avgPathPosition:Math.round(10*e.avgPathPosition)/10,pathPositionVariance:Math.round(100*e.pathPositionVariance)/100,floodParticipationRate:Math.round(100*e.floodParticipationRate)/100,pathDiversity:e.pathDiversity,positionDelayMs:l,observationSymmetry:Math.round(100*e.observationSymmetry)/100,dataConfidence:e.dataConfidence})}return s}(K,0,x,st),at=function(t,e){const n=new Map,s=new Map(e.map(t=>[t.key,t]));for(const o of e)n.set(o.key,0);if(0===t.paths.length)return n;for(const a of t.paths)for(let t=0;t<a.hops.length-1;t++){const s=a.hops[t],i=a.hops[t+1];for(const t of e){const e=o(t.fromHash),r=o(t.toHash);if(e===s&&r===i||e===i&&r===s){const e=n.get(t.key)||0;n.set(t.key,e+a.observationCount);break}}}const i=Math.max(...n.values(),1);for(const[o,a]of n)n.set(o,a/i);for(const[o,a]of n){const t=s.get(o);if(t){const e=.5+.5*t.symmetryRatio;n.set(o,a*e)}}return n}(st,K),rt=function(t,e=3,o=.3){return[...t.entries()].filter(([,t])=>t>=o).sort((t,e)=>e[1]-t[1]).slice(0,e).map(([t])=>t)}(at,3,.3),{nodeMobility:ct,mobileNodes:ht}=function(t,e){const o=new Map,n=[];if(0===t.paths.length)return{nodeMobility:o,mobileNodes:n};const s=36e5,i=t.paths.map(t=>t.lastSeen).sort((t,e)=>t-e),a=i[0],r=i[i.length-1],c=Math.ceil((r-a)/s)||1,h=new Map;for(const u of t.paths){const t=Math.floor((u.lastSeen-a)/s);for(const o of u.hops){let n=o;for(const[t]of Object.entries(e))if((t.startsWith("0x")?t.slice(2,4).toUpperCase():t.slice(0,2).toUpperCase())===o.toUpperCase()){n=t;break}let s=h.get(n);s||(s={paths:new Set,firstSeen:u.firstSeen,lastSeen:u.lastSeen,windowPresence:new Set},h.set(n,s)),s.paths.add(u.id),s.firstSeen=Math.min(s.firstSeen,u.firstSeen),s.lastSeen=Math.max(s.lastSeen,u.lastSeen),s.windowPresence.add(t)}}for(const[u,l]of h){const t=l.paths.size,e=l.lastSeen-l.firstSeen,s=e>0?e/36e5:0,i=c>0?l.windowPresence.size/c:1,a=(1-i)*(1-.5*Math.min(t/10,1)),r=a>.3,h={hash:u,pathVolatility:a,pathDiversity:t,avgPathLifespanHours:s,isMobile:r,lastSeen:l.lastSeen,activeWindowRatio:i};o.set(u,h),r&&n.push(u)}return n.sort((t,e)=>{var n,s;const i=(null==(n=o.get(t))?void 0:n.pathVolatility)??0;return((null==(s=o.get(e))?void 0:s.pathVolatility)??0)-i}),{nodeMobility:o,mobileNodes:n}}(st,S),ut=function(t,e,n,s=20){const i=[];if(0===t.paths.length)return i;const a=new Map;for(const l of e){const t=o(l.fromHash),e=o(l.toHash);a.set(`${t}>${e}`,l),a.set(`${e}>${t}`,l)}const r=new Set;for(const l of n)r.add(o(l));const c=new Map;for(const o of t.paths){if(0===o.hops.length)continue;const t=o.hops[o.hops.length-1],e=c.get(t)||[];e.push(o.id),c.set(t,e)}const h=[...t.paths].sort((t,e)=>e.observationCount-t.observationCount),u=Date.now();for(const o of h.slice(0,s)){if(o.hops.length<2)continue;let t=0,e=1/0,n=null,s=0,h=!1;for(let i=0;i<o.hops.length-1;i++){const c=o.hops[i],u=o.hops[i+1],l=`${c}>${u}`,f=a.get(l);if(f){const o=f.packetCount>0?f.certainCount/f.packetCount:0;t+=o,s++,o<e&&(e=o,n=f.key)}else t+=.1,s++,.1<e&&(e=.1,n=C(c,u));(r.has(c)||r.has(u))&&(h=!0)}const l=s>0?t/s:0,f=e===1/0?0:e,d=(u-o.lastSeen)/36e5,p=Math.exp(-d/24),g=o.observationCount>10&&d<12?.5+.5*(1-d/12):d>48?-.5:0,m=o.hops[o.hops.length-1],y=c.get(m)||[],S=Math.max(0,y.length-1),v="direct"===o.routeType?20:30,b=o.hops.length*v,M=.4*l,w=.3*p,P=(g+1)/2*.15,x=.15*Math.min(S/3,1),H=Math.round(100*(M+w+P+x))/100;i.push({pathKey:o.id,hops:[...o.hops],healthScore:H,weakestLinkKey:n,weakestLinkConfidence:Math.round(100*f)/100,avgEdgeCertainty:Math.round(100*l)/100,observationTrend:Math.round(100*g)/100,alternatePathsCount:S,estimatedLatencyMs:b,observationCount:o.observationCount,routeType:"unknown"===o.routeType?"mixed":o.routeType,lastSeen:o.lastSeen,involvesHub:h})}return i.sort((t,e)=>e.healthScore-t.healthScore),i}(st,K,W,20),lt=[];for(const t of U.values()){let e=null,o=0,n=0;for(const[s,i]of t.resolvedHashes){if(s===v)continue;const t=i.count>0?i.confidenceSum/i.count:0,a=i.count*t;a>o&&(o=a,e=s,n=t)}e&&lt.push({hash:e,prefix:t.prefix,count:t.count,confidence:n,avgRssi:t.rssiCount>0?t.rssiSum/t.rssiCount:null,avgSnr:t.snrCount>0?t.snrSum/t.snrCount:null,lastSeen:t.lastSeen})}lt.sort((t,e)=>e.count-t.count);let ft=0,dt=0;const pt=[],gt=[];let mt=0;for(const[t,e]of H){ft+=e.confidence;const o=e.candidates.length;e.isUnambiguous||(dt++,gt.push({prefix:t,candidateCount:o}),e.confidence<.5&&pt.push(t));for(const e of k.values())if(e.hash.toUpperCase().startsWith(t)||e.hash.slice(2).toUpperCase().startsWith(t)){mt+=e.resolutionCount;break}}gt.sort((t,e)=>e.candidateCount-t.candidateCount);const Ct=gt.slice(0,5);return{edges:K,validatedEdges:Z,weakEdges:tt,certainEdges:Z,uncertainEdges:[],edgeMap:et,maxPacketCount:X,maxCertainCount:J,neighborAffinity:D,fullAffinity:k,localPrefix:E,centrality:F,hubNodes:W,loops:ot,loopEdgeKeys:nt,txDelayRecommendations:it,pathRegistry:st,edgeBetweenness:at,backboneEdges:rt,nodeMobility:ct,mobileNodes:ht,pathHealth:ut,lastHopNeighbors:lt,disambiguationStats:{totalPrefixes:H.size,unambiguousPrefixes:H.size-dt,collisionPrefixes:dt,collisionRate:H.size>0?Math.round(dt/H.size*1e3)/10:0,avgConfidence:H.size>0?Math.round(ft/H.size*1e3)/1e3:0,lowConfidencePrefixes:pt,highCollisionPrefixes:Ct,totalResolutions:mt}}}self.onmessage=t=>{const{type:e,payload:o}=t.data;if("compute"!==e)return void self.postMessage({type:"error",error:`Unknown message type: ${e}`});const n=performance.now();try{const{packets:t,neighbors:e,localHash:i,localLat:a,localLon:r,airtimeMs:c}=o,h=y(t,e,i,.5,a,r),u={type:"result",payload:{edges:h.edges,validatedEdges:h.validatedEdges,weakEdges:h.weakEdges,certainEdges:h.certainEdges,uncertainEdges:h.uncertainEdges,maxPacketCount:h.maxPacketCount,maxCertainCount:h.maxCertainCount,localPrefix:h.localPrefix,hubNodes:h.hubNodes,edgeMapEntries:Array.from(h.edgeMap.entries()),neighborAffinityEntries:Array.from(h.neighborAffinity.entries()),fullAffinityEntries:Array.from(h.fullAffinity.entries()),centralityEntries:Array.from(h.centrality.entries()),loops:h.loops,loopEdgeKeyEntries:Array.from(h.loopEdgeKeys),txDelayRecommendationEntries:Array.from(h.txDelayRecommendations.entries()),pathRegistry:(s=h.pathRegistry,{paths:s.paths,byEndpointsEntries:Array.from(s.byEndpoints.entries()),canonicalPathsEntries:Array.from(s.canonicalPaths.entries()),totalObservations:s.totalObservations,uniquePathCount:s.uniquePathCount}),edgeBetweennessEntries:Array.from(h.edgeBetweenness.entries()),backboneEdges:h.backboneEdges,nodeMobilityEntries:Array.from(h.nodeMobility.entries()),mobileNodes:h.mobileNodes,pathHealth:h.pathHealth,lastHopNeighbors:h.lastHopNeighbors,disambiguationStats:h.disambiguationStats},computeTimeMs:performance.now()-n};self.postMessage(u)}catch(i){const t={type:"error",error:i instanceof Error?i.message:"Unknown error in topology worker"};self.postMessage(t)}var s}}();
