!function(){"use strict";const n=216e5;function t(n){return n?n.startsWith("0x")||n.startsWith("0X")?n.slice(2,4).toUpperCase():n.slice(0,2).toUpperCase():""}function o(n){if(!n)return null;if(Array.isArray(n))return n;if("string"==typeof n)try{const t=JSON.parse(n);return Array.isArray(t)?t:null}catch{return null}return null}self.onmessage=r=>{const{type:e,payload:c}=r.data;if("compute"!==e)return void self.postMessage({type:"error",error:`Unknown message type: ${e}`});const s=performance.now();try{const{packets:r,nodeHashes:e}=c,f=function(r,e){const c=Date.now(),s=c-6048e5,f=new Map;for(const n of e){const o=t(n);o&&(f.has(o)||f.set(o,new Set),f.get(o).add(n))}const a=new Map,i=new Map;for(const n of e)a.set(n,new Map),i.set(n,c);for(const p of r){const r=p.timestamp??0,e=r>1e12?r:1e3*r;if(e<s)continue;const c=new Set,u=o(p.forwarded_path??p.original_path);if(u&&u.length>0)for(const n of u){const t=String(n).toUpperCase();f.has(t)&&c.add(t)}if((!u||0===u.length)&&p.src_hash){const n=t(p.src_hash);f.has(n)&&c.add(n)}if(c.size>0){const t=Math.floor((e-s)/n),o=Math.max(0,Math.min(27,t));for(const n of c){const t=f.get(n);for(const n of t){const t=a.get(n);t.set(o,(t.get(o)||0)+1),e<i.get(n)&&i.set(n,e)}}}}const u=new Map;for(const t of e){const o=a.get(t),r=i.get(t);if(0===o.size){u.set(t,[]);continue}const e=Math.max(0,Math.floor((r-s)/n)),c=[];for(let t=e;t<28;t++)c.push({idx:t-e,count:o.get(t)||0,timestamp:s+t*n});u.set(t,c)}return u}(r,e),a=performance.now()-s,i={type:"result",payload:{sparklineEntries:Array.from(f.entries())},computeTimeMs:a,packetCount:r.length,nodeCount:e.length};self.postMessage(i)}catch(f){const n={type:"error",error:f instanceof Error?f.message:"Unknown error in sparkline worker"};self.postMessage(n)}}}();
