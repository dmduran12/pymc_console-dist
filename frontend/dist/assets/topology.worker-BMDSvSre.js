!function(){"use strict";const t=100;function e(t){return 1===t||0===t}function o(t){return 2===t||3===t}function n(t){return t.startsWith("0x")||t.startsWith("0X")?t.slice(2,4).toUpperCase():t.slice(0,2).toUpperCase()}function s(t,e){let o=t.forwarded_path??t.original_path;if("string"==typeof o)try{o=JSON.parse(o)}catch{return null}if(!o||!Array.isArray(o)||0===o.length)return null;const s=o.map(t=>String(t).toUpperCase()),i=e?n(e):null,a=s[s.length-1],r=null!==i&&a===i,c=r?s.slice(0,-1):[...s];return{effective:c,original:s,hadLocal:r,effectiveLength:c.length}}function i(t,e){return e-t}function a(t){return t}function r(t,e,o,n){const s=(o-t)*Math.PI/180,i=(n-e)*Math.PI/180,a=Math.sin(s/2)*Math.sin(s/2)+Math.cos(t*Math.PI/180)*Math.cos(o*Math.PI/180)*Math.sin(i/2)*Math.sin(i/2);return 2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a))*6371e3}function c(t){return t<500?1:t<2e3?.8:t<5e3?.6:t<1e4?.4:t<2e4?.2:.1}function l(t){if(t.contact_type){const e=t.contact_type.toLowerCase();if("repeater"===e||"rep"===e)return!0;if("companion"===e||"client"===e||"cli"===e)return!1;if("room server"===e||"room_server"===e||"room"===e||"server"===e)return!1}return!0===t.is_repeater||(t.is_repeater,!1)}function h(t,e){if(!t||t<=0)return.1;const o=(Math.floor(Date.now()/1e3)-t)/3600;return o<0?1:Math.exp(-o/12)}function u(t){return!(!t||t<=0)&&(Math.floor(Date.now()/1e3)-t)/3600>336}function f(t,e,o){const n=e.toUpperCase(),s=t.get(n);if(!s||0===s.candidates.length)return{hash:null,confidence:0};if(null==o?void 0:o.isLastHop)return{hash:s.bestMatch,confidence:s.confidence};if(1===(null==o?void 0:o.position))return{hash:s.bestMatch,confidence:s.confidence};if((null==o?void 0:o.position)&&s.bestMatchForPosition.has(o.position)){const t=s.bestMatchForPosition.get(o.position),e=Math.max(t.confidence,s.confidence);return{hash:t.hash,confidence:e}}if((null==o?void 0:o.adjacentPrefixes)&&o.adjacentPrefixes.length>0){let t=s.bestMatch,e=0;for(const n of s.candidates){let s=0;for(const t of o.adjacentPrefixes)s+=n.adjacentPrefixCounts.get(t.toUpperCase())||0;const i=n.combinedScore+s/Math.max(1,n.totalAdjacentObservations)*.3;i>e&&(e=i,t=n.hash)}return{hash:t,confidence:s.confidence}}return{hash:s.bestMatch,confidence:s.confidence}}function d(t,e){return`${e}:${t.join(">")}`}function p(t,e){return`${t}→${e}`}function g(t){const n=t.route??t.route_type;return e(n)?"flood":o(n)?"direct":"unknown"}function m(t,e){return t.toUpperCase()===(e.startsWith("0x")?e.slice(2,4).toUpperCase():e.slice(0,2).toUpperCase())}function C(t,e){return[t,e].sort().join("-")}function y(y,S,b,v=.4,M,w,P){const x=[...y].sort((t,e)=>(t.timestamp??0)-(e.timestamp??0)),k=function(t,e,o,a,c){const f=new Map,d=function(t){const e={};for(const[o,n]of Object.entries(t))l(n)&&(e[o]=n);return e}(e),p=new Map,g=void 0!==a&&void 0!==c&&(0!==a||0!==c);if(o){const t=n(o),e={hash:o,prefix:t,positionCounts:new Array(5).fill(0),totalAppearances:0,typicalPosition:0,positionConsistency:0,adjacentPrefixCounts:new Map,totalAdjacentObservations:0,latitude:a,longitude:c,distanceToLocal:0,srcGeoEvidenceScore:0,srcGeoEvidenceCount:0,lastSeenTimestamp:Math.floor(Date.now()/1e3),recencyScore:1,positionScore:0,cooccurrenceScore:0,geographicScore:1,combinedScore:0};p.set(t,[e])}for(const[s,i]of Object.entries(d)){const t=n(s),e=i.last_seen??0;if(u(e))continue;let o;const l=!0===i.zero_hop;g&&i.latitude&&i.longitude&&(0!==i.latitude||0!==i.longitude)&&(o=r(a,c,i.latitude,i.longitude));let f=.2;void 0!==o?f=o<500?1:o<2e3?.8:o<5e3?.6:o<1e4?.4:o<2e4?.2:.1:i.latitude&&i.longitude&&(f=.5),l&&(f=Math.max(f,.95));const d=h(e),m={hash:s,prefix:t,positionCounts:new Array(5).fill(0),totalAppearances:0,typicalPosition:0,positionConsistency:0,adjacentPrefixCounts:new Map,totalAdjacentObservations:0,latitude:i.latitude,longitude:i.longitude,distanceToLocal:o,srcGeoEvidenceScore:0,srcGeoEvidenceCount:0,lastSeenTimestamp:e,recencyScore:d,positionScore:0,cooccurrenceScore:0,geographicScore:f,combinedScore:0},C=p.get(t)||[];C.push(m),p.set(t,C)}for(const n of t){const t=s(n,o);if(!t||0===t.effectiveLength)continue;const a=t.effective,c=n.src_hash,l=c?e[c]:void 0,h=(null==l?void 0:l.latitude)&&(null==l?void 0:l.longitude)&&(0!==l.latitude||0!==l.longitude);for(let e=0;e<a.length;e++){const o=a[e],n=p.get(o);if(!n)continue;const s=i(e,t.effectiveLength),c=Math.min(s-1,4);for(const t of n){if(t.positionCounts[c]++,t.totalAppearances++,1===s&&n.length>1&&h&&t.latitude&&t.longitude){const e=r(l.latitude,l.longitude,t.latitude,t.longitude);let o=0;o=e<500?1:e<2e3?.8:e<5e3?.5:e<1e4?.3:.1,void 0!==t.distanceToLocal&&(t.distanceToLocal<500?o*=1.2:t.distanceToLocal<2e3?o*=1:o*=.8),t.srcGeoEvidenceScore+=o,t.srcGeoEvidenceCount++}if(e>0&&n.length>1&&t.latitude&&t.longitude){const o=a[e-1],n=p.get(o);if(n&&n.length>0){let e,o,s=0;if(1===n.length){const t=n[0];t.latitude&&t.longitude&&(e=t.latitude,o=t.longitude,s=1)}else{const t=[...n].sort((t,e)=>e.combinedScore-t.combinedScore),i=t[0],a=t[1];if(i.latitude&&i.longitude&&i.combinedScore>0){const t=a?(i.combinedScore-a.combinedScore)/i.combinedScore:1;s=Math.min(1,t+.3),s>.4&&(e=i.latitude,o=i.longitude)}}if(void 0!==e&&void 0!==o){const n=r(t.latitude,t.longitude,e,o);let i=0;i=n<500?1:n<2e3?.8:n<5e3?.5:n<1e4?.3:.1,i*=s,t.srcGeoEvidenceScore+=i,t.srcGeoEvidenceCount++}}}if(s>1&&n.length>1&&t.latitude&&t.longitude){const o=e+1;if(o<a.length){const e=a[o],n=p.get(e);if(n&&n.length>0){let e,o,s=0;if(1===n.length){const t=n[0];t.latitude&&t.longitude&&(e=t.latitude,o=t.longitude,s=1)}else{const t=[...n].sort((t,e)=>e.combinedScore-t.combinedScore),i=t[0],a=t[1];if(i.latitude&&i.longitude&&i.combinedScore>0){const t=a?(i.combinedScore-a.combinedScore)/i.combinedScore:1;s=Math.min(1,t+.3),s>.4&&(e=i.latitude,o=i.longitude)}}if(void 0!==e&&void 0!==o){const n=r(t.latitude,t.longitude,e,o);let i=0;i=n<500?1:n<2e3?.8:n<5e3?.5:n<1e4?.3:.1,i*=s,t.srcGeoEvidenceScore+=i,t.srcGeoEvidenceCount++}}}}if(e>0){const o=a[e-1];t.adjacentPrefixCounts.set(o,(t.adjacentPrefixCounts.get(o)||0)+1),t.totalAdjacentObservations++}if(e<a.length-1){const o=a[e+1];t.adjacentPrefixCounts.set(o,(t.adjacentPrefixCounts.get(o)||0)+1),t.totalAdjacentObservations++}}}}let m=1,C=1;for(const n of p.values())for(const t of n)m=Math.max(m,t.totalAppearances),C=Math.max(C,t.totalAdjacentObservations);for(const n of p.values())for(const t of n){if(t.totalAppearances>0){let e=0,o=1;for(let s=0;s<5;s++)t.positionCounts[s]>e&&(e=t.positionCounts[s],o=s+1);t.typicalPosition=o,t.positionConsistency=e/t.totalAppearances;const n=t.totalAppearances/m;t.positionScore=.6*t.positionConsistency+.4*n}if(t.totalAdjacentObservations>0&&(t.cooccurrenceScore=t.totalAdjacentObservations/C),t.combinedScore=.15*t.positionScore+.15*t.cooccurrenceScore+.35*t.geographicScore+.35*t.recencyScore,t.srcGeoEvidenceCount>0){const e=t.srcGeoEvidenceScore/t.srcGeoEvidenceCount*Math.min(t.srcGeoEvidenceCount/50,1)*.3;t.combinedScore+=e}}for(const[n,s]of p){s.sort((t,e)=>e.combinedScore-t.combinedScore);const t=s.length>0?s[0].hash:null;let e=0;if(1===s.length)e=1;else if(s.length>1){const t=s[0].combinedScore,o=s[1].combinedScore;t>0&&(e=Math.min(1,(t-o)/t)),s[0].totalAppearances>2*s[1].totalAppearances&&(e=Math.min(1,e+.2));const n=0,i=s[0].positionCounts[n]||0,a=i+(s[1].positionCounts[n]||0);if(a>=20&&i>=10){const t=i/a;if(t>=.8){const o=.3+1.5*(t-.8);e=Math.min(1,e+o)}}const r=s.reduce((t,e)=>t+e.combinedScore,0);if(r>0){const t=[],o=s.reduce((t,e)=>t+(e.positionCounts[0]||0),0);for(const e of s){const n=o*(e.combinedScore/r);t.push(n)}const n=t[0],i=n+(t[1]||0);if(i>=20&&n>=10){const t=n/i;if(t>=.6){const o=.2+1*(t-.6);e=Math.min(1,e+o)}}}const c=s[0].srcGeoEvidenceScore,l=s[1].srcGeoEvidenceScore;if(s[0].srcGeoEvidenceCount>=10&&c>1.5*l){const t=l>0?c/(c+l):1,o=Math.min(.3,.6*(t-.5));e=Math.min(1,e+o)}}const o=new Map;for(let n=1;n<=5;n++){const t=[...s].sort((t,e)=>{const o=t.positionCounts[n-1]||0;return(e.positionCounts[n-1]||0)-o});if(t.length>0&&t[0].positionCounts[n-1]>0){const e=t[0];let s=1;if(t.length>1){const o=e.positionCounts[n-1],i=o+(t[1].positionCounts[n-1]||0);s=i>0?o/i:0}o.set(n,{hash:e.hash,confidence:s})}}const i={prefix:n,candidates:s,bestMatch:t,confidence:e,isUnambiguous:1===s.length,bestMatchForPosition:o};f.set(n,i)}return f}(x,S,b,M,w),E=function(t,e,o,n,a,l){const h=new Map,u=void 0!==o&&void 0!==n&&(0!==o||0!==n);for(const[s,i]of Object.entries(e)){let t=null,e=.5;u&&i.latitude&&i.longitude&&(0!==i.latitude||0!==i.longitude)&&(t=r(o,n,i.latitude,i.longitude),e=c(t)),i.zero_hop&&(e=Math.max(e,.9)),h.set(s,{hash:s,frequency:0,directForwardCount:0,distanceMeters:t,proximityScore:e,hopPositionCounts:[0,0,0,0,0],avgHopDistance:0,typicalHopPosition:0,hopConsistencyScore:0,frequencyScore:0,combinedScore:0,avgDisambiguationConfidence:0,collisionCount:0,resolutionCount:0})}const d=new Map;for(const r of t){const t=s(r,a);if(t&&t.effectiveLength>=1){const e=t.effective;for(let o=0;o<e.length;o++){const n=e[o],s=i(o,t.effectiveLength);if(l){const t=f(l,n,{position:s,adjacentPrefixes:[...o>0?[e[o-1]]:[],...o<e.length-1?[e[o+1]]:[]],isLastHop:1===s});if(t.hash){const e=h.get(t.hash);if(e){e.frequency++,e.resolutionCount++;const o=d.get(t.hash)||0;d.set(t.hash,o+t.confidence);const i=l.get(n.toUpperCase());i&&!i.isUnambiguous&&e.collisionCount++;const a=Math.min(s-1,4);e.hopPositionCounts[a]++,1===s&&e.directForwardCount++}}}else for(const[t,e]of h)if(m(n,t)){e.frequency++;const t=Math.min(s-1,4);e.hopPositionCounts[t]++,1===s&&e.directForwardCount++}}}if((!t||0===t.effectiveLength)&&r.src_hash){const t=h.get(r.src_hash);if(t){t.frequency++,t.directForwardCount++,t.hopPositionCounts[0]++,t.resolutionCount++;const e=d.get(r.src_hash)||0;d.set(r.src_hash,e+1)}}}let p=0;for(const s of h.values())p=Math.max(p,s.frequency);for(const s of h.values()){let t=0,e=0,o=0,n=1;for(let a=0;a<s.hopPositionCounts.length;a++){const i=s.hopPositionCounts[a],r=a+1;t+=i,e+=i*r,i>o&&(o=i,n=r)}s.avgHopDistance=t>0?e/t:0,s.typicalHopPosition=n,t>0&&o>0&&(s.hopConsistencyScore=o/t),s.frequencyScore=p>0?s.frequency/p:0;const i=d.get(s.hash)||0;s.avgDisambiguationConfidence=s.resolutionCount>0?i/s.resolutionCount:0,s.combinedScore=.3*s.proximityScore+.3*s.hopConsistencyScore+.4*s.frequencyScore}return h}(x,S,M,w,b,k),H=b?n(b):null,D=new Map;for(const[t,e]of E)D.set(t,e.combinedScore);const A=new Map,L=new Map,R=new Map,j=new Map,N=new Map,U=Math.floor(Date.now()/1e3),_=(t,n,s,i,a,r,c)=>{const l=C(t,n),h=A.get(l),[u,f]=t<n?[t,n]:[n,t],d=t===u,p=e(r)||void 0===r,g=o(r),m=(t=>{if(!t||t<=0)return.1;const e=(U-t)/3600;return e<0?1:Math.exp(-e/12)})(c);if(h)h.count++,h.confidenceSum+=s,h.recencySum+=m,h.minHopDistance=Math.min(h.minHopDistance,a),a<h.hopDistanceCounts.length&&h.hopDistanceCounts[a]++,i?h.certainCount++:h.uncertainCount++,d?h.forwardCount++:h.reverseCount++,p?h.floodCount++:g&&h.directCount++;else{const t=[0,0,0,0,0,0,0,0,0,0];a<t.length&&t[a]++,A.set(l,{fromHash:u,toHash:f,key:l,count:1,confidenceSum:s,minHopDistance:a,hopDistanceCounts:t,certainCount:i?1:0,uncertainCount:i?0:1,forwardCount:d?1:0,reverseCount:d?0:1,floodCount:p?1:0,directCount:g?1:0,recencySum:m})}};for(const t of x){const e=s(t,b);if(!e)continue;const o=e.effective,n=e.effectiveLength,r=e.original,c=new Set;if(t.src_hash&&r.length>=1){const e=f(k,r[0],{position:n,adjacentPrefixes:r.length>1?[r[1]]:[]}),o=t.src_hash;if(e.hash&&e.hash!==o){const s=Object.keys(S).includes(o),i=e.confidence>=.6&&s,a=e.confidence*(s?1:.8),r=n+1,l=t.route??t.route_type;_(o,e.hash,a,i,r,l,t.timestamp),c.add(o),c.add(e.hash)}}if(b&&n>=1){const e=n-1,s=o[e],i=4===(t.type??t.payload_type);if(i){const e=N.get(s);e?(e.count++,"number"!=typeof t.rssi||isNaN(t.rssi)||(e.rssiSum+=t.rssi,e.rssiCount++),"number"!=typeof t.snr||isNaN(t.snr)||(e.snrSum+=t.snr,e.snrCount++),e.lastSeen=Math.max(e.lastSeen,t.timestamp??0)):N.set(s,{prefix:s,count:1,rssiSum:"number"!=typeof t.rssi||isNaN(t.rssi)?0:t.rssi,rssiCount:"number"!=typeof t.rssi||isNaN(t.rssi)?0:1,snrSum:"number"!=typeof t.snr||isNaN(t.snr)?0:t.snr,snrCount:"number"!=typeof t.snr||isNaN(t.snr)?0:1,lastSeen:t.timestamp??0,resolvedHashes:new Map})}const a=f(k,s,{position:1,adjacentPrefixes:e>0?[o[e-1]]:[],isLastHop:!0});if(i&&a.hash){const t=N.get(s);if(t){const e=t.resolvedHashes.get(a.hash);e?(e.count++,e.confidenceSum+=a.confidence):t.resolvedHashes.set(a.hash,{count:1,confidenceSum:a.confidence})}}if(a.hash&&a.hash!==b){const e=!0,o=a.confidence,n=t.route??t.route_type;_(a.hash,b,o,e,0,n,t.timestamp),c.add(a.hash),c.add(b),j.set(a.hash,(j.get(a.hash)||0)+1)}}for(let s=0;s<n-1;s++){const e=o[s],r=o[s+1],l=i(s,n),h=i(s+1,n),u=1===h,d=f(k,e,{position:l,adjacentPrefixes:[...s>0?[o[s-1]]:[],o[s+1]]}),p=f(k,r,{position:h,adjacentPrefixes:[o[s],...s+2<n?[o[s+2]]:[]],isLastHop:u});if(!d.hash||!p.hash)continue;if(d.hash===p.hash)continue;const g=d.confidence>=.6&&p.confidence>=.6,m=p.confidence>=.9,C=u&&p.confidence>=.6,y=g||m||C;c.add(d.hash),c.add(p.hash),s>0&&s<n-1&&R.set(d.hash,(R.get(d.hash)||0)+1);const S=m?p.confidence:d.confidence*p.confidence;if(!y&&S<v)continue;const b=a(h),M=t.route??t.route_type;_(d.hash,p.hash,S,y,b,M,t.timestamp)}for(const t of c)L.set(t,(L.get(t)||0)+1)}const F=new Map;let T=0;for(const[t,e]of L){const o=R.get(t)||0,n=e>0?o/e:0;F.set(t,n),T=Math.max(T,n)}if(T>0)for(const[t,e]of F)F.set(t,e/T);const G=new Set,O=new Set,$=[...j.values()].reduce((t,e)=>t+e,0);for(const[t,e]of j){if(t===b)continue;const o=$>0?e/$:0;if(o>=.1){G.add(t);const e=F.get(t)||0;F.set(t,Math.max(e,o))}else if(o>=.07){O.add(t);const e=F.get(t)||0;F.set(t,Math.max(e,o))}}const q=Array.from(G),z=Array.from(O),I=[],K=[],W=[];let B=0,V=0;const J=new Set(q),X=new Set;for(const t of A.values()){const e=t.confidenceSum/t.count;B=Math.max(B,t.count),V=Math.max(V,t.certainCount);const o=J.has(t.fromHash)||J.has(t.toHash),n=t.certainCount>=5,s=t.forwardCount+t.reverseCount,i=s>0?Math.min(t.forwardCount,t.reverseCount)/Math.max(t.forwardCount,t.reverseCount):0;let a="balanced";i<.7&&s>0&&(a=t.forwardCount>t.reverseCount?"forward":"reverse");const r=t.floodCount+t.directCount>0&&t.directCount>t.floodCount,c=t.count>0?t.recencySum/t.count:0,l={fromHash:t.fromHash,toHash:t.toHash,key:t.key,packetCount:t.count,avgConfidence:e,strength:0,avgRecency:c,hopDistanceFromLocal:t.minHopDistance,isHubConnection:o,isCertain:n,certainCount:t.certainCount,forwardCount:t.forwardCount,reverseCount:t.reverseCount,symmetryRatio:i,dominantDirection:a,floodCount:t.floodCount,directCount:t.directCount,isDirectPathEdge:r};I.push(l),n&&(K.push(l),X.add(t.key))}for(const t of I)!X.has(t.key)&&t.packetCount>=2&&W.push(t);for(const t of I){const e=B>0?t.packetCount/B:0;t.strength=.4*e+.4*t.avgConfidence+.2*t.avgRecency}I.sort((t,e)=>e.certainCount-t.certainCount),K.sort((t,e)=>{const o=t.certainCount+(t.isHubConnection?1e3:0);return e.certainCount+(e.isHubConnection?1e3:0)-o}),W.sort((t,e)=>t.packetCount-e.packetCount);const Q=K.slice(0,100),Y=W.slice(0,100),Z=new Map(I.map(t=>[t.key,t])),{loops:tt,loopEdgeKeys:et}=function(t,e,o=1){if(t.length<3)return{loops:[],loopEdgeKeys:new Set};const n=new Map,s=new Map;for(const l of t)s.set(l.key,l),n.has(l.fromHash)||n.set(l.fromHash,new Set),n.has(l.toHash)||n.set(l.toHash,new Set),n.get(l.fromHash).add(l.toHash),n.get(l.toHash).add(l.fromHash);const i=[],a=new Set,r=new Set;function c(t,e,o){if(t===e)return[t];const s=new Set([t]),i=[{node:t,path:[t]}];for(;i.length>0;){const{node:t,path:a}=i.shift(),r=n.get(t);if(r)for(const n of r)if(C(t,n)!==o){if(n===e)return[...a,n];s.has(n)||(s.add(n),i.push({node:n,path:[...a,n]}))}}return null}for(const l of t){const t=c(l.fromHash,l.toHash,l.key);if(t&&t.length>=2){const n=t,c=[l.key];for(let e=0;e<t.length-1;e++){const o=C(t[e],t[e+1]);c.push(o)}const h=[...n].sort().join(",");if(r.has(h))continue;r.add(h);let u=0,f=1/0;for(const t of c){const e=s.get(t);e&&(u+=e.certainCount,f=Math.min(f,e.certainCount),a.add(t))}const d=c.length>0?u/c.length:0,p=!!e&&n.includes(e),g={id:`loop-${i.length}`,edgeKeys:c,nodes:n,size:c.length,avgCertainCount:d,minCertainCount:f===1/0?0:f,includesLocal:p,strength:o>0?f===1/0?0:f/o:0};i.push(g)}}return i.sort((t,e)=>t.includesLocal!==e.includesLocal?t.includesLocal?-1:1:e.strength-t.strength),{loops:i,loopEdgeKeys:a}}(K,b,V);for(const t of I)t.isLoopEdge=et.has(t.key);const ot=function(t,e){const o=new Map,n=new Map;let s=0;for(const r of t){if(!r.src_hash)continue;const t=r.original_path??r.forwarded_path;if(!t||!Array.isArray(t)||0===t.length)continue;const n=t.map(t=>"string"==typeof t?t.toUpperCase().slice(0,2):String(t).toUpperCase().slice(0,2)),i=e||"unknown",a=r.src_hash,c=d(n,a);let l=o.get(c);l||(l={id:c,hops:n,srcHash:a,dstHash:i,observationCount:0,firstSeen:r.timestamp,lastSeen:r.timestamp,routeType:g(r),hopCount:n.length},o.set(c,l)),l.observationCount++,l.lastSeen=Math.max(l.lastSeen,r.timestamp),l.firstSeen=Math.min(l.firstSeen,r.timestamp),s++,"direct"===g(r)&&"direct"!==l.routeType&&(l.routeType="direct")}const i=Array.from(o.values());for(const r of i){const t=p(r.srcHash,r.dstHash),e=n.get(t)||[];e.push(r),n.set(t,e)}for(const r of n.values())r.sort((t,e)=>e.observationCount-t.observationCount);const a=new Map;for(const[r,c]of n)c.length>0&&a.set(r,c[0]);return{paths:i,byEndpoints:n,canonicalPaths:a,totalObservations:s,uniquePathCount:i.length}}(x,b),nt=function(e,o,n,s){const i=new Map;if(0===e.length||0===n.length)return i;const a=t=>{const e=.2*Math.round(t/.2);return Math.max(0,Math.min(5,e))},r=t=>Math.floor(5*t),c=new Set;for(const t of e)c.add(t.fromHash),c.add(t.toHash);const l=n.map(t=>t.timestamp).filter(t=>void 0!==t&&t>0).sort((t,e)=>t-e),h=l.length>=2?(l[l.length-1]-l[0])/60:1,u=new Map;for(const t of e)u.has(t.fromHash)||u.set(t.fromHash,[]),u.has(t.toHash)||u.set(t.toHash,[]),u.get(t.fromHash).push(t),u.get(t.toHash).push(t);const f=new Set;for(const t of e)t.isLoopEdge&&f.add(t.key);const d=new Set;for(const[,t]of s.canonicalPaths)for(const e of t.hops)d.add(e.toUpperCase());const p=new Map;for(const t of c){const e=u.get(t)||[];if(0===e.length)continue;const o=t.startsWith("0x")?t.slice(2,4).toUpperCase():t.slice(0,2).toUpperCase(),n=new Set;let i=0,a=0,r=0,c=0,l=0,d=0,g=0;for(const s of e){const e=s.fromHash===t?s.toHash:s.fromHash;n.add(e),i+=s.packetCount,a+=s.certainCount,r=Math.max(r,s.certainCount),c+=s.symmetryRatio,l+=s.floodCount,s.isDirectPathEdge&&d++,f.has(s.key)&&g++}const m=n.size,C=e.length>0?c/e.length:0,y=e.length>0?a/e.length:0,S=s.paths.filter(t=>t.hops.some(t=>t.toUpperCase()===o)),b=S.length;let v=0;for(const[,t]of s.canonicalPaths)t.hops.some(t=>t.toUpperCase()===o)&&v++;const M=S.length>0?S.reduce((t,e)=>t+e.hopCount,0)/S.length:0;p.set(t,{neighborCount:m,totalEdgePackets:i,maxEdgeCertainCount:r,avgEdgeCertainCount:y,avgSymmetry:C,forwardingBurden:0,floodForwardRatio:i>0?l/i:0,pathCount:b,canonicalPathCount:v,avgPathLength:M,loopParticipation:e.length>0?g/e.length:0,isInLoop:g>0,edgeDensity:0,trafficRate:h>0?i/h:0,directPathEdgeRatio:e.length>0?d/e.length:0})}const g=[],m=[],C=[],y=[];for(const[,P]of p)P.totalEdgePackets>=t&&(g.push(P.totalEdgePackets),m.push(P.neighborCount),C.push(P.pathCount),y.push(P.trafficRate));g.sort((t,e)=>t-e),m.sort((t,e)=>t-e),C.sort((t,e)=>t-e),y.sort((t,e)=>t-e);const S=(t,e)=>{if(0===t.length)return.5;const o=t.findIndex(t=>t>=e);return-1===o?1:0===o?0:o/t.length},b=m.length>0?Math.max(...m):1;for(const[,t]of p)t.forwardingBurden=S(g,t.totalEdgePackets),t.edgeDensity=b>0?t.neighborCount/b:0;const v=new Map;for(const P of c){const e=p.get(P);if(!e||e.totalEdgePackets<t)continue;const o=P.startsWith("0x")?P.slice(2,4).toUpperCase():P.slice(0,2).toUpperCase(),i=e.forwardingBurden,a=S(m,e.neighborCount),r=.3*e.avgSymmetry,c=Math.min(1,a+r),l=.6*(s.canonicalPaths.size>0?e.canonicalPathCount/s.canonicalPaths.size:0)+.4*S(C,e.pathCount),h=e.loopParticipation,u=.3*i+.3*c+.2*l+.2*h;let f,d=.4+3.6*u;(u<.1&&e.neighborCount<=2||d<.4)&&(d=.4),f=u>=.7&&e.neighborCount>=4?"backbone":e.neighborCount>=4?"hub":u>=.3&&e.neighborCount>=2?"relay":"edge";const g=s.paths.filter(t=>t.hops.some(t=>t.toUpperCase()===o)).flatMap(t=>{const e=t.hops.findIndex(t=>t.toUpperCase()===o);return e>=0?[e+1]:[]}),y=g.length>0?g.reduce((t,e)=>t+e,0)/g.length:0;let b=0;g.length>1&&(b=g.reduce((t,e)=>t+Math.pow(e-y,2),0)/g.length);const M=.3*Math.min(e.avgEdgeCertainCount/10,1)+.3*Math.min(n.length/1e3,1)+.4*e.avgSymmetry;let w;w=n.length<t?"insufficient":n.length<500?"low":n.length<1e3?"medium":"high",v.set(P,{compositeScore:u,rawFloodDelay:d,networkRole:f,collisionRisk:c,floodParticipationRate:e.floodForwardRatio,avgPathPosition:y,pathPositionVariance:b,pathDiversity:e.pathCount,trafficIntensity:e.trafficRate,confidence:M,observationSymmetry:e.avgSymmetry,dataConfidence:w,factors:{forwarding:i,collision:c,criticality:l,redundancy:h}})}const M=new Map;for(const[t,P]of v){const e=r(a(P.rawFloodDelay));M.has(e)||M.set(e,[]),M.get(e).push(t)}const w=new Map;for(const[,t]of M){if(t.length<=1){if(1===t.length){const e=t[0],o=v.get(e);w.set(e,a(o.rawFloodDelay))}continue}const e=[...t].sort((t,e)=>{const o=v.get(t),n=v.get(e);return o.compositeScore-n.compositeScore});for(let t=0;t<e.length;t++){const o=e[t],n=v.get(o),s=t%3*.2;w.set(o,a(n.rawFloodDelay+s))}}for(const P of c){const e=p.get(P);if(!e||e.totalEdgePackets<t){i.set(P,{floodFactor:0,directFactor:0,floodSlots:0,directSlots:0,floodDelaySec:0,directDelaySec:0,txDelayFactor:0,directTxDelayFactor:0,trafficIntensity:0,directNeighborCount:(null==e?void 0:e.neighborCount)??0,collisionRisk:0,confidence:0,insufficientData:!0,networkRole:"edge",rationale:"Insufficient data (<100 packets observed)",adjustment:"stable",avgPathPosition:0,pathPositionVariance:0,floodParticipationRate:0,pathDiversity:0,positionDelayMs:0,observationSymmetry:(null==e?void 0:e.avgSymmetry)??0,dataConfidence:"insufficient"});continue}const o=v.get(P),n=w.get(P)??a(o.rawFloodDelay),s=a(.28*n),c=r(n),l=r(s);let h,u={backbone:`Backbone: ${e.neighborCount} neighbors, ${Math.round(100*e.avgSymmetry)}% symmetric`,hub:`Hub: ${e.neighborCount} neighbors`,relay:`Relay: ${Math.round(100*e.avgSymmetry)}% symmetric traffic`,edge:"Edge node"}[o.networkRole];o.observationSymmetry>=.6?u+=". High bidirectional visibility (+1 slot)":o.observationSymmetry<.3&&(u+=". ⚠️ Low symmetry (possible observer bias)"),"low"===o.dataConfidence&&(u+=". Limited data"),h=c>r(1)?"increase":c<r(1)?"decrease":"stable";const f=0;i.set(P,{floodFactor:n,directFactor:s,floodSlots:c,directSlots:l,floodDelaySec:n,directDelaySec:s,txDelayFactor:n,directTxDelayFactor:s,trafficIntensity:Math.round(10*o.trafficIntensity)/10,directNeighborCount:e.neighborCount,collisionRisk:Math.round(100*o.collisionRisk)/100,confidence:o.confidence,insufficientData:!1,networkRole:o.networkRole,rationale:u,adjustment:h,avgPathPosition:Math.round(10*o.avgPathPosition)/10,pathPositionVariance:Math.round(100*o.pathPositionVariance)/100,floodParticipationRate:Math.round(100*o.floodParticipationRate)/100,pathDiversity:o.pathDiversity,positionDelayMs:f,observationSymmetry:Math.round(100*o.observationSymmetry)/100,dataConfidence:o.dataConfidence})}return i}(I,0,x,ot),st=function(t,e){const o=new Map,s=new Map(e.map(t=>[t.key,t]));for(const n of e)o.set(n.key,0);if(0===t.paths.length)return o;for(const a of t.paths)for(let t=0;t<a.hops.length-1;t++){const s=a.hops[t],i=a.hops[t+1];for(const t of e){const e=n(t.fromHash),r=n(t.toHash);if(e===s&&r===i||e===i&&r===s){const e=o.get(t.key)||0;o.set(t.key,e+a.observationCount);break}}}const i=Math.max(...o.values(),1);for(const[n,a]of o)o.set(n,a/i);for(const[n,a]of o){const t=s.get(n);if(t){const e=.5+.5*t.symmetryRatio;o.set(n,a*e)}}return o}(ot,I),it=function(t,e=3,o=.3){return[...t.entries()].filter(([,t])=>t>=o).sort((t,e)=>e[1]-t[1]).slice(0,e).map(([t])=>t)}(st,3,.3),{nodeMobility:at,mobileNodes:rt}=function(t,e){const o=new Map,n=[];if(0===t.paths.length)return{nodeMobility:o,mobileNodes:n};const s=36e5,i=t.paths.map(t=>t.lastSeen).sort((t,e)=>t-e),a=i[0],r=i[i.length-1],c=Math.ceil((r-a)/s)||1,l=new Map;for(const h of t.paths){const t=Math.floor((h.lastSeen-a)/s);for(const o of h.hops){let n=o;for(const[t]of Object.entries(e))if((t.startsWith("0x")?t.slice(2,4).toUpperCase():t.slice(0,2).toUpperCase())===o.toUpperCase()){n=t;break}let s=l.get(n);s||(s={paths:new Set,firstSeen:h.firstSeen,lastSeen:h.lastSeen,windowPresence:new Set},l.set(n,s)),s.paths.add(h.id),s.firstSeen=Math.min(s.firstSeen,h.firstSeen),s.lastSeen=Math.max(s.lastSeen,h.lastSeen),s.windowPresence.add(t)}}for(const[h,u]of l){const t=u.paths.size,e=u.lastSeen-u.firstSeen,s=e>0?e/36e5:0,i=c>0?u.windowPresence.size/c:1,a=(1-i)*(1-.5*Math.min(t/10,1)),r=a>.3,l={hash:h,pathVolatility:a,pathDiversity:t,avgPathLifespanHours:s,isMobile:r,lastSeen:u.lastSeen,activeWindowRatio:i};o.set(h,l),r&&n.push(h)}return n.sort((t,e)=>{var n,s;const i=(null==(n=o.get(t))?void 0:n.pathVolatility)??0;return((null==(s=o.get(e))?void 0:s.pathVolatility)??0)-i}),{nodeMobility:o,mobileNodes:n}}(ot,S),ct=function(t,e,o,s=20){const i=[];if(0===t.paths.length)return i;const a=new Map;for(const u of e){const t=n(u.fromHash),e=n(u.toHash);a.set(`${t}>${e}`,u),a.set(`${e}>${t}`,u)}const r=new Set;for(const u of o)r.add(n(u));const c=new Map;for(const n of t.paths){if(0===n.hops.length)continue;const t=n.hops[n.hops.length-1],e=c.get(t)||[];e.push(n.id),c.set(t,e)}const l=[...t.paths].sort((t,e)=>e.observationCount-t.observationCount),h=Date.now();for(const n of l.slice(0,s)){if(n.hops.length<2)continue;let t=0,e=1/0,o=null,s=0,l=!1;for(let i=0;i<n.hops.length-1;i++){const c=n.hops[i],h=n.hops[i+1],u=`${c}>${h}`,f=a.get(u);if(f){const n=f.packetCount>0?f.certainCount/f.packetCount:0;t+=n,s++,n<e&&(e=n,o=f.key)}else t+=.1,s++,.1<e&&(e=.1,o=C(c,h));(r.has(c)||r.has(h))&&(l=!0)}const u=s>0?t/s:0,f=e===1/0?0:e,d=(h-n.lastSeen)/36e5,p=Math.exp(-d/24),g=n.observationCount>10&&d<12?.5+.5*(1-d/12):d>48?-.5:0,m=n.hops[n.hops.length-1],y=c.get(m)||[],S=Math.max(0,y.length-1),b="direct"===n.routeType?20:30,v=n.hops.length*b,M=.4*u,w=.3*p,P=(g+1)/2*.15,x=.15*Math.min(S/3,1),k=Math.round(100*(M+w+P+x))/100;i.push({pathKey:n.id,hops:[...n.hops],healthScore:k,weakestLinkKey:o,weakestLinkConfidence:Math.round(100*f)/100,avgEdgeCertainty:Math.round(100*u)/100,observationTrend:Math.round(100*g)/100,alternatePathsCount:S,estimatedLatencyMs:v,observationCount:n.observationCount,routeType:"unknown"===n.routeType?"mixed":n.routeType,lastSeen:n.lastSeen,involvesHub:l})}return i.sort((t,e)=>e.healthScore-t.healthScore),i}(ot,I,q,20),lt=[];for(const t of N.values()){let e=null,o=0,n=0;for(const[s,i]of t.resolvedHashes){if(s===b)continue;const t=i.count>0?i.confidenceSum/i.count:0,a=i.count*t;a>o&&(o=a,e=s,n=t)}e&&lt.push({hash:e,prefix:t.prefix,count:t.count,confidence:n,avgRssi:t.rssiCount>0?t.rssiSum/t.rssiCount:null,avgSnr:t.snrCount>0?t.snrSum/t.snrCount:null,lastSeen:t.lastSeen})}lt.sort((t,e)=>e.count-t.count);let ht=0,ut=0;const ft=[],dt=[];let pt=0;for(const[t,e]of k){ht+=e.confidence;const o=e.candidates.length;e.isUnambiguous||(ut++,dt.push({prefix:t,candidateCount:o}),e.confidence<.5&&ft.push(t));for(const e of E.values())if(e.hash.toUpperCase().startsWith(t)||e.hash.slice(2).toUpperCase().startsWith(t)){pt+=e.resolutionCount;break}}dt.sort((t,e)=>e.candidateCount-t.candidateCount);const gt=dt.slice(0,5);return{edges:I,validatedEdges:Q,weakEdges:Y,certainEdges:Q,uncertainEdges:[],edgeMap:Z,maxPacketCount:B,maxCertainCount:V,neighborAffinity:D,fullAffinity:E,localPrefix:H,centrality:F,hubNodes:q,gatewayNodes:z,loops:tt,loopEdgeKeys:et,txDelayRecommendations:nt,pathRegistry:ot,edgeBetweenness:st,backboneEdges:it,nodeMobility:at,mobileNodes:rt,pathHealth:ct,lastHopNeighbors:lt,disambiguationStats:{totalPrefixes:k.size,unambiguousPrefixes:k.size-ut,collisionPrefixes:ut,collisionRate:k.size>0?Math.round(ut/k.size*1e3)/10:0,avgConfidence:k.size>0?Math.round(ht/k.size*1e3)/1e3:0,lowConfidencePrefixes:ft,highCollisionPrefixes:gt,totalResolutions:pt}}}self.onmessage=t=>{const{type:e,payload:o}=t.data;if("compute"!==e)return void self.postMessage({type:"error",error:`Unknown message type: ${e}`});const n=performance.now();try{const{packets:t,neighbors:e,localHash:i,localLat:a,localLon:r,airtimeMs:c}=o,l=y(t,e,i,.5,a,r),h={type:"result",payload:{edges:l.edges,validatedEdges:l.validatedEdges,weakEdges:l.weakEdges,certainEdges:l.certainEdges,uncertainEdges:l.uncertainEdges,maxPacketCount:l.maxPacketCount,maxCertainCount:l.maxCertainCount,localPrefix:l.localPrefix,hubNodes:l.hubNodes,gatewayNodes:l.gatewayNodes,edgeMapEntries:Array.from(l.edgeMap.entries()),neighborAffinityEntries:Array.from(l.neighborAffinity.entries()),fullAffinityEntries:Array.from(l.fullAffinity.entries()),centralityEntries:Array.from(l.centrality.entries()),loops:l.loops,loopEdgeKeyEntries:Array.from(l.loopEdgeKeys),txDelayRecommendationEntries:Array.from(l.txDelayRecommendations.entries()),pathRegistry:(s=l.pathRegistry,{paths:s.paths,byEndpointsEntries:Array.from(s.byEndpoints.entries()),canonicalPathsEntries:Array.from(s.canonicalPaths.entries()),totalObservations:s.totalObservations,uniquePathCount:s.uniquePathCount}),edgeBetweennessEntries:Array.from(l.edgeBetweenness.entries()),backboneEdges:l.backboneEdges,nodeMobilityEntries:Array.from(l.nodeMobility.entries()),mobileNodes:l.mobileNodes,pathHealth:l.pathHealth,lastHopNeighbors:l.lastHopNeighbors,disambiguationStats:l.disambiguationStats},computeTimeMs:performance.now()-n};self.postMessage(h)}catch(i){const t={type:"error",error:i instanceof Error?i.message:"Unknown error in topology worker"};self.postMessage(t)}var s}}();
